<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CORRIDORS</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Teko:wght@300;400;500;600;700&family=JetBrains+Mono:wght@300;400;500&display=swap');

  /* ── Design tokens ─────────────────────────────────────────────── */
  :root {
    --bg:          #0d0e0f;
    --surface:     #141618;
    --surface2:    #1a1d20;
    --border:      #2a2e33;
    --border-hi:   #3d4349;
    --text:        #c8cdd4;
    --text-dim:    #5a6070;
    --text-bright: #e8ecf0;
    --amber:       #d4903a;
    --amber-hi:    #f0b050;
    --amber-dim:   #8a5a1a;
    --gold:        #c8a84a;
    --p0:          #d4903a;   /* Player 0 — amber */
    --p1:          #5a9fd4;   /* Player 1 — steel blue */
    --p0-dim:      #7a4a14;
    --p1-dim:      #2a4a6a;
    --wall-arch:   #8a6a3a;   /* Architects — sandstone */
    --wall-path:   #3a7a5a;   /* Pathfinders — emerald */
    --wall-ward:   #5a6a8a;   /* Wardens — slate blue */
    --wall-phan:   #7a4a7a;   /* Phantoms — violet */
    --wall-adept:  #8a5a3a;   /* Adepts — burnished copper */
    --wall-default:#5a5a5a;
    --wall-reinforced: #d4903a; /* Reinforced walls — amber glow */
    --legal-move:  rgba(212,144,58,0.15);
    --legal-move-border: rgba(212,144,58,0.5);
    --danger:      #c04040;
    --success:     #50a060;
    --cell:        52px;
    --gap:         3px;
    --wall-w:      6px;
  }

  /* ── Reset & base ──────────────────────────────────────────────── */
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    overflow-x: hidden;
  }

  /* ── Header ────────────────────────────────────────────────────── */
  header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 14px 24px;
    border-bottom: 1px solid var(--border);
    background: var(--surface);
  }
  .logo {
    font-family: 'Teko', sans-serif;
    font-size: 28px;
    font-weight: 700;
    letter-spacing: 0.25em;
    color: var(--amber);
    text-transform: uppercase;
  }
  .logo span { color: var(--text-dim); }
  .header-meta {
    display: flex;
    align-items: center;
    gap: 20px;
    font-size: 11px;
    color: var(--text-dim);
    letter-spacing: 0.1em;
  }
  .turn-badge {
    font-family: 'Teko', sans-serif;
    font-size: 18px;
    font-weight: 500;
    letter-spacing: 0.15em;
    padding: 4px 12px;
    border: 1px solid var(--border-hi);
    color: var(--text-bright);
  }

  /* ── Main layout ───────────────────────────────────────────────── */
  main {
    display: grid;
    grid-template-columns: 220px 1fr 220px;
    gap: 0;
    flex: 1;
    padding: 0;
  }

  /* ── Side panels ───────────────────────────────────────────────── */
  .panel {
    background: var(--surface);
    border-right: 1px solid var(--border);
    padding: 20px 16px;
    display: flex;
    flex-direction: column;
    gap: 16px;
  }
  .panel.right {
    border-right: none;
    border-left: 1px solid var(--border);
  }
  .panel-label {
    font-family: 'Teko', sans-serif;
    font-size: 13px;
    font-weight: 500;
    letter-spacing: 0.2em;
    color: var(--text-dim);
    text-transform: uppercase;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--border);
  }

  /* ── Champion card ─────────────────────────────────────────────── */
  .champion-card {
    position: relative;
  }
  .champion-name {
    font-family: 'Teko', sans-serif;
    font-size: 26px;
    font-weight: 600;
    letter-spacing: 0.1em;
    line-height: 1;
    margin-bottom: 2px;
  }
  .champion-title {
    font-size: 10px;
    color: var(--text-dim);
    letter-spacing: 0.12em;
    text-transform: uppercase;
    margin-bottom: 12px;
  }
  .faction-badge {
    display: inline-block;
    font-size: 9px;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    padding: 2px 6px;
    border: 1px solid currentColor;
    margin-bottom: 14px;
  }
  .faction-Architects { color: var(--wall-arch); }
  .faction-Pathfinders { color: var(--wall-path); }
  .faction-Wardens { color: var(--wall-ward); }
  .faction-Phantoms { color: var(--wall-phan); }
  .faction-Adepts { color: var(--wall-adept); }
  

  /* ── Stats grid ────────────────────────────────────────────────── */
  .stats-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
  }
  .stat {
    background: var(--surface2);
    border: 1px solid var(--border);
    padding: 7px 8px;
  }
  .stat-label {
    font-size: 9px;
    color: var(--text-dim);
    letter-spacing: 0.12em;
    text-transform: uppercase;
    margin-bottom: 3px;
  }
  .stat-value {
    font-family: 'Teko', sans-serif;
    font-size: 22px;
    font-weight: 500;
    line-height: 1;
    color: var(--text-bright);
  }

  /* ── Ultimate bar ──────────────────────────────────────────────── */
  .ultimate-section {
    background: var(--surface2);
    border: 1px solid var(--border);
    padding: 10px;
  }
  .ultimate-label {
    font-size: 9px;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    color: var(--text-dim);
    margin-bottom: 6px;
  }
  .ultimate-name {
    font-family: 'Teko', sans-serif;
    font-size: 15px;
    letter-spacing: 0.1em;
    color: var(--text-bright);
    margin-bottom: 8px;
  }
  .charge-bar {
    display: flex;
    gap: 3px;
  }
  .charge-pip {
    flex: 1;
    height: 5px;
    background: var(--border);
    transition: background 0.3s;
  }
  .charge-pip.filled { background: var(--amber); }
  .charge-pip.ready  { background: var(--amber-hi); animation: pulse-pip 1s ease-in-out infinite; }
  @keyframes pulse-pip {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }
  .charge-text {
    font-size: 10px;
    color: var(--text-dim);
    margin-top: 5px;
    letter-spacing: 0.08em;
  }

  /* ── Passive ───────────────────────────────────────────────────── */
  .passive-section {
    background: var(--surface2);
    border: 1px solid var(--border);
    padding: 10px;
  }
  .passive-name {
    font-family: 'Teko', sans-serif;
    font-size: 14px;
    letter-spacing: 0.1em;
    color: var(--text-bright);
    margin-bottom: 4px;
  }
  .passive-desc {
    font-size: 10px;
    line-height: 1.5;
    color: var(--text-dim);
  }

  /* ── Status effects ────────────────────────────────────────────── */
  .status-effects {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
  }
  .status-chip {
    font-size: 9px;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    padding: 2px 6px;
    background: var(--surface2);
    border: 1px solid var(--danger);
    color: var(--danger);
  }

  /* ── Hand ──────────────────────────────────────────────────────── */
  .hand-section {}
  .hand-label {
    font-size: 9px;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    color: var(--text-dim);
    margin-bottom: 8px;
  }
  .hand-cards {
    display: flex;
    flex-direction: column;
    gap: 5px;
  }
  .card {
    background: var(--surface2);
    border: 1px solid var(--border);
    padding: 8px 10px;
    cursor: pointer;
    transition: border-color 0.15s, background 0.15s;
    position: relative;
  }
  .card:hover {
    border-color: var(--border-hi);
    background: #202428;
  }
  .card.selected {
    border-color: var(--amber);
    background: rgba(212,144,58,0.08);
  }
  .card.card-disabled {
    opacity: 0.35;
    cursor: not-allowed;
  }
  .card-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 3px;
  }
  .card-name {
    font-family: 'Teko', sans-serif;
    font-size: 14px;
    letter-spacing: 0.08em;
    color: var(--text-bright);
  }
  .card-type-badge {
    font-size: 8px;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    padding: 1px 5px;
    border: 1px solid currentColor;
  }
  .type-Wall       { color: var(--wall-default); }
  .type-Movement   { color: var(--wall-path); }
  .type-Disruption { color: var(--danger); }
  .type-Relic      { color: var(--gold); }
  .card-desc {
    font-size: 9px;
    line-height: 1.4;
    color: var(--text-dim);
  }
  .rarity-dot {
    display: inline-block;
    width: 5px; height: 5px;
    border-radius: 50%;
    margin-right: 4px;
    vertical-align: middle;
  }
  .rarity-Common    { background: #505a60; }
  .rarity-Uncommon  { background: #50a060; }
  .rarity-Rare      { background: #4a80d0; }
  .rarity-Legendary { background: #c0a030; }
  .rarity-Signature { background: var(--amber); }

  .hidden-card {
    background: var(--surface2);
    border: 1px solid var(--border);
    padding: 8px 10px;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .hidden-card-icon {
    width: 20px; height: 28px;
    border: 1px solid var(--border-hi);
    background: repeating-linear-gradient(
      45deg,
      var(--border),
      var(--border) 2px,
      transparent 2px,
      transparent 8px
    );
  }
  .hidden-card-label {
    font-size: 10px;
    color: var(--text-dim);
    letter-spacing: 0.08em;
  }

  /* ── Centre — board area ───────────────────────────────────────── */
  .board-area {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    padding: 24px 20px;
    gap: 16px;
    background: var(--bg);
    position: relative;
  }

  /* ── Turn banner ───────────────────────────────────────────────── */
  .turn-banner {
    font-family: 'Teko', sans-serif;
    font-size: 15px;
    font-weight: 500;
    letter-spacing: 0.3em;
    text-transform: uppercase;
    padding: 8px 20px;
    border: 1px solid var(--border);
    background: var(--surface);
    color: var(--text-bright);
    width: 100%;
    text-align: center;
  }
  .turn-banner.p0 { border-color: var(--p0-dim); color: var(--p0); }
  .turn-banner.p1 { border-color: var(--p1-dim); color: var(--p1); }

  /* ── Board wrapper ─────────────────────────────────────────────── */
  .board-wrapper {
    position: relative;
  }

  /* ── The grid ──────────────────────────────────────────────────── */
  .board-grid {
    display: grid;
    grid-template-columns: repeat(9, var(--cell));
    grid-template-rows: repeat(9, var(--cell));
    gap: var(--gap);
    position: relative;
    background: var(--border);
    padding: var(--gap);
  }

  .cell {
    width: var(--cell);
    height: var(--cell);
    background: var(--surface);
    position: relative;
    cursor: default;
    transition: background 0.12s;
  }
  .cell.legal-move {
    background: var(--legal-move);
    cursor: pointer;
  }
  .cell.legal-move::after {
    content: '';
    position: absolute;
    inset: 4px;
    border: 1px solid var(--legal-move-border);
    pointer-events: none;
  }
  .cell.legal-move:hover {
    background: rgba(212,144,58,0.25);
  }
  .cell.goal-row-p0 {
    background: rgba(212,144,58,0.04);
    border-top: 1px solid var(--amber-dim);
  }
  .cell.goal-row-p1 {
    background: rgba(90,159,212,0.04);
    border-bottom: 1px solid var(--p1-dim);
  }
  .cell.wall-preview {
    background: rgba(212,144,58,0.12) !important;
  }

  /* ── Goal labels ───────────────────────────────────────────────── */
  .goal-label {
    position: absolute;
    font-size: 9px;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    color: var(--text-dim);
    pointer-events: none;
  }
  .goal-label.top    { top: -20px; left: 0; right: 0; text-align: center; }
  .goal-label.bottom { bottom: -20px; left: 0; right: 0; text-align: center; }

  /* ── Champion piece ────────────────────────────────────────────── */
  .champion-piece {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    width: 32px; height: 32px;
    border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    font-family: 'Teko', sans-serif;
    font-size: 14px;
    font-weight: 600;
    letter-spacing: 0.05em;
    border: 2px solid currentColor;
    z-index: 10;
    transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
    pointer-events: none;
  }
  .champion-piece.p0 {
    background: rgba(212,144,58,0.15);
    color: var(--p0);
    box-shadow: 0 0 12px rgba(212,144,58,0.3);
  }
  .champion-piece.p1 {
    background: rgba(90,159,212,0.15);
    color: var(--p1);
    box-shadow: 0 0 12px rgba(90,159,212,0.3);
  }
  .champion-piece.active-piece {
    box-shadow: 0 0 20px currentColor;
  }

  /* ── Walls ─────────────────────────────────────────────────────── */
  .wall-layer {
    position: absolute;
    top: var(--gap);
    left: var(--gap);
    pointer-events: none;   /* default: no clicks */
    z-index: 20;
  }
  .wall-layer.pick-mode {
    pointer-events: auto;   /* enabled during wall selection */
  }
  .wall-segment {
    position: absolute;
    background: var(--wall-default);
    transition: opacity 0.2s;
  }
  .wall-segment.wall-pickable {
    outline: 2px dashed var(--amber) !important;
    cursor: pointer !important;
    filter: brightness(1.5);
    animation: wallPulse 0.8s ease-in-out infinite alternate;
  }
  .wall-segment.wall-redirect {
    outline: 2px dashed var(--p1) !important;
    filter: brightness(1.6) hue-rotate(180deg);
    animation: wallPulse 0.8s ease-in-out infinite alternate;
  }
  .wall-segment.wall-reconstructable {
    outline: 2px dashed #e05050 !important;
    filter: brightness(1.4);
    animation: wallPulse 0.8s ease-in-out infinite alternate;
  }
  .wall-segment.wall-sealable {
    outline: 2px dashed var(--success) !important;
  }
  .wall-segment.wall-punchable {
    outline: 2px dashed var(--danger) !important;
    animation: wallPulse 0.6s ease-in-out infinite alternate;
  }
  .wall-tile-punch {
    /* Expanded hit area — visually thin bar, large click zone */
    background: transparent !important;
    outline: none !important;
    animation: none !important;
    display: flex; align-items: center; justify-content: center;
    overflow: visible;
    z-index: 12;
  }
  .wall-tile-punch::after {
    content: '';
    display: block;
    background: var(--danger);
    opacity: 0.7;
    border-radius: 2px;
    transition: opacity 0.1s, transform 0.1s;
  }
  .wall-tile-punch.H-tile::after {
    width: calc(100% - 2px); height: 6px;
  }
  .wall-tile-punch.V-tile::after {
    width: 6px; height: calc(100% - 2px);
  }
  .wall-tile-punch:hover::after {
    background: #ff4444 !important;
    opacity: 1 !important;
    transform: scaleY(2.5);
    box-shadow: 0 0 8px rgba(255,80,80,0.8);
  }
  .wall-tile-punch.V-tile:hover::after {
    transform: scaleX(2.5) scaleY(1);
    box-shadow: 0 0 8px rgba(255,80,80,0.8);
  }
  @keyframes wallPulse {
    from { filter: brightness(1.2); }
    to   { filter: brightness(2.0); }
  }
  .wall-segment.wall-immune {
    outline: 1px solid var(--success);
  }
  /* Phantom walls:
     - Owner (player 0 or 1) sees theirs with a distinctive translucent teal tint
     - The opponent sees opponent's phantoms as normal solid walls (realistic deception)
     - We add .phantom-own class only when rendered from owner's perspective */
  .wall-segment.phantom {
    /* default: looks like a real wall to the opponent */
  }
  .wall-segment.phantom.phantom-own {
    background: rgba(40, 180, 160, 0.55) !important;
    border: 1px solid rgba(80, 220, 200, 0.7) !important;
    box-shadow: 0 0 6px rgba(40, 200, 180, 0.5) !important;
  }
  .wall-segment.owner-0 { background: var(--p0-dim); }
  .wall-segment.owner-1 { background: var(--p1-dim); }
  .wall-segment.durable-1 { box-shadow: 0 0 6px rgba(212,144,58,0.4); }
  .wall-segment.immune   { border: 1px solid var(--gold); }

  /* Wall placement interactive overlay */
  .wall-overlay {
    position: absolute;
    top: var(--gap);
    left: var(--gap);
    z-index: 15;
    pointer-events: none;
  }
  .wall-hotspot {
    position: absolute;
    cursor: crosshair;
    background: transparent;
    transition: background 0.1s;
  }
  .wall-hotspot:hover {
    background: rgba(212,144,58,0.2);
  }
  .wall-hotspot.preview-active {
    background: rgba(212,144,58,0.35);
  }

  /* ── Decoy tokens ──────────────────────────────────────────────── */
  .decoy-token {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    width: 24px; height: 24px;
    border-radius: 50%;
    border: 2px dashed var(--text-dim);
    background: transparent;
    pointer-events: none;
    z-index: 8;
    opacity: 0.5;
  }

  /* ── Trap tokens ───────────────────────────────────────────────── */
  .trap-token {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    width: 8px; height: 8px;
    background: var(--danger);
    transform: translate(-50%, -50%) rotate(45deg);
    pointer-events: none;
    z-index: 8;
  }

  /* ── Wall placement preview ────────────────────────────────────── */
  .wall-preview-segment {
    position: absolute;
    background: rgba(212,144,58,0.5);
    border: 1px solid var(--amber);
    pointer-events: none;
    z-index: 25;
    transition: opacity 0.1s;
  }
  .wall-preview-segment.invalid {
    background: rgba(192,64,64,0.5);
    border-color: var(--danger);
  }

  /* ── Action bar ────────────────────────────────────────────────── */
  .action-bar {
    display: flex;
    gap: 8px;
    width: 100%;
  }
  .action-btn {
    flex: 1;
    padding: 10px 8px;
    background: var(--surface);
    border: 1px solid var(--border);
    color: var(--text);
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    cursor: pointer;
    transition: all 0.15s;
  }
  .action-btn:hover:not(:disabled) {
    border-color: var(--border-hi);
    color: var(--text-bright);
    background: var(--surface2);
  }
  .action-btn:disabled {
    opacity: 0.3;
    cursor: not-allowed;
  }
  .action-btn.primary {
    border-color: var(--amber-dim);
    color: var(--amber);
  }
  .action-btn.primary:hover:not(:disabled) {
    border-color: var(--amber);
    background: rgba(212,144,58,0.1);
  }
  .action-btn.danger {
    border-color: #5a2020;
    color: var(--danger);
  }
  .action-btn.danger:hover:not(:disabled) {
    border-color: var(--danger);
    background: rgba(192,64,64,0.1);
  }
  .action-btn.active {
    border-color: var(--amber);
    background: rgba(212,144,58,0.15);
    color: var(--amber-hi);
  }

  /* ── Mode indicator ────────────────────────────────────────────── */
  .mode-indicator {
    font-size: 10px;
    letter-spacing: 0.12em;
    color: var(--text-dim);
    text-align: center;
    min-height: 16px;
  }
  .mode-indicator.active { color: var(--amber); }
  .mode-indicator.error  { color: var(--danger); }
  .mode-indicator.success { color: var(--success); }

  /* ── Game log ──────────────────────────────────────────────────── */
  .log-section { flex: 1; min-height: 0; }
  .log-scroll {
    height: 180px;
    overflow-y: auto;
    background: var(--surface2);
    border: 1px solid var(--border);
    padding: 8px;
    scrollbar-width: thin;
    scrollbar-color: var(--border-hi) transparent;
  }
  .log-entry {
    font-size: 10px;
    line-height: 1.6;
    color: var(--text-dim);
    border-bottom: 1px solid rgba(255,255,255,0.04);
    padding: 2px 0;
  }
  .log-entry .turn-num { color: var(--text-dim); margin-right: 6px; }
  .log-entry .p0-tag { color: var(--p0); }
  .log-entry .p1-tag { color: var(--p1); }
  .log-entry .sys-tag { color: var(--gold); }

  /* ── Draw screen ───────────────────────────────────────────────── */
  .draw-screen {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 20px;
    padding: 40px;
    text-align: center;
    min-height: 400px;
  }
  .draw-screen-name {
    font-family: 'Teko', sans-serif;
    font-size: 48px;
    font-weight: 700;
    letter-spacing: 0.1em;
  }
  .draw-screen-subtitle {
    font-size: 12px;
    letter-spacing: 0.2em;
    color: var(--text-dim);
    text-transform: uppercase;
  }
  .draw-screen-btn {
    padding: 12px 32px;
    background: transparent;
    border: 1px solid var(--amber);
    color: var(--amber);
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    cursor: pointer;
    transition: all 0.2s;
    margin-top: 8px;
  }
  .draw-screen-btn:hover {
    background: rgba(212,144,58,0.1);
    box-shadow: 0 0 20px rgba(212,144,58,0.2);
  }

  /* ── Victory screen ────────────────────────────────────────────── */
  .victory-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.85);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 100;
    backdrop-filter: blur(4px);
  }
  .victory-card {
    background: var(--surface);
    border: 1px solid var(--border-hi);
    padding: 48px 64px;
    text-align: center;
    max-width: 480px;
  }
  .victory-title {
    font-family: 'Teko', sans-serif;
    font-size: 64px;
    font-weight: 700;
    letter-spacing: 0.1em;
    line-height: 1;
    margin-bottom: 8px;
  }
  .victory-subtitle {
    font-size: 11px;
    letter-spacing: 0.25em;
    text-transform: uppercase;
    color: var(--text-dim);
    margin-bottom: 32px;
  }
  .victory-stats {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    margin-bottom: 32px;
  }
  .victory-stat {
    background: var(--surface2);
    border: 1px solid var(--border);
    padding: 12px;
  }
  .victory-stat-label {
    font-size: 9px;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    color: var(--text-dim);
    margin-bottom: 4px;
  }
  .victory-stat-value {
    font-family: 'Teko', sans-serif;
    font-size: 28px;
    font-weight: 500;
    color: var(--text-bright);
  }

  /* ── Wall orientation toggle ───────────────────────────────────── */
  .orientation-toggle {
    display: flex;
    gap: 0;
  }
  .orient-btn {
    flex: 1;
    padding: 6px;
    background: var(--surface);
    border: 1px solid var(--border);
    color: var(--text-dim);
    font-family: 'JetBrains Mono', monospace;
    font-size: 9px;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    cursor: pointer;
    transition: all 0.15s;
  }
  .orient-btn:first-child { border-right: none; }
  .orient-btn.active {
    background: var(--surface2);
    border-color: var(--amber-dim);
    color: var(--amber);
  }

  /* Own reinforced walls — amber glow */
  .wall-segment.wall-reinforced.owner-0 {
    background: var(--wall-reinforced) !important;
    box-shadow: 0 0 6px rgba(212,144,58,0.6), 0 0 12px rgba(212,144,58,0.3) !important;
    border: 1px solid #f0c060 !important;
  }
  /* Opponent reinforced walls — blue halo */
  .wall-segment.wall-reinforced.owner-1 {
    background: #1a3a5a !important;
    box-shadow: 0 0 6px rgba(90,160,212,0.7), 0 0 14px rgba(90,160,212,0.35) !important;
    border: 1px solid #5ab0f0 !important;
  }

  .wall-segment.wall-binding {
    background: #3a6b4a !important;
    border: 1px solid #5adc7a !important;
    box-shadow: 0 0 5px rgba(90,220,120,0.6), 0 0 10px rgba(90,220,120,0.25) !important;
    animation: bindingPulse 1.2s ease-in-out infinite alternate;
  }
  @keyframes bindingPulse {
    from { box-shadow: 0 0 4px rgba(90,220,120,0.5); }
    to   { box-shadow: 0 0 10px rgba(90,220,120,0.9), 0 0 18px rgba(90,220,120,0.4); }
  }

  /* ── Scrollbar ─────────────────────────────────────────────────── */
  ::-webkit-scrollbar { width: 4px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: var(--border-hi); }

  /* ── Debug overlay ─────────────────────────────────────────────── */
  #debug-overlay {
    display: none;
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 360px;
    max-height: 400px;
    overflow-y: auto;
    background: rgba(10,10,12,0.95);
    border: 1px solid var(--amber-dim);
    padding: 12px;
    font-size: 9px;
    line-height: 1.5;
    color: var(--text-dim);
    z-index: 200;
    font-family: 'JetBrains Mono', monospace;
  }
  #debug-overlay.visible { display: block; }
  .debug-title {
    font-family: 'Teko', sans-serif;
    font-size: 14px;
    letter-spacing: 0.2em;
    color: var(--amber);
    margin-bottom: 8px;
  }

  /* ── Wall count indicator ──────────────────────────────────────── */
  .wall-count {
    display: flex;
    gap: 3px;
    flex-wrap: wrap;
    margin-top: 4px;
  }
  .wall-pip {
    width: 10px; height: 3px;
    background: var(--border-hi);
  }
  .wall-pip.filled { background: var(--amber); }

  /* ── Coord labels on board ─────────────────────────────────────── */
  .board-coords {
    position: absolute;
    pointer-events: none;
    font-size: 8px;
    color: var(--border-hi);
    font-family: 'JetBrains Mono', monospace;
  }

  /* ── Phase display ─────────────────────────────────────────────── */
  .phase-dot {
    display: inline-block;
    width: 6px; height: 6px;
    border-radius: 50%;
    margin-right: 5px;
    vertical-align: middle;
  }
  .phase-draw    .phase-dot { background: var(--text-dim); }
  .phase-action  .phase-dot { background: var(--amber); animation: pulse-pip 1s infinite; }
  .phase-end_turn .phase-dot { background: var(--success); }

  /* ── Champion Select Screen ────────────────────────────────────────── */
  #champion-select-overlay {
    position: fixed; inset: 0;
    background: var(--bg);
    z-index: 300;
    display: flex; flex-direction: column;
    align-items: center; justify-content: flex-start;
    padding: 40px 24px;
    overflow-y: auto;
  }
  .cs-title {
    font-family: 'Teko', sans-serif;
    font-size: 42px; font-weight: 700;
    letter-spacing: 0.3em; color: var(--amber);
    margin-bottom: 4px;
  }
  .cs-subtitle {
    font-size: 11px; letter-spacing: 0.2em;
    color: var(--text-dim); text-transform: uppercase;
    margin-bottom: 36px;
  }
  .cs-grid {
    display: grid;
    grid-template-columns: repeat(3, 280px);
    gap: 16px;
    margin-bottom: 40px;
  }
  .cs-card {
    background: var(--surface);
    border: 1px solid var(--border);
    padding: 20px;
    cursor: pointer;
    transition: border-color 0.15s, background 0.15s, transform 0.15s;
    position: relative;
  }
  .cs-card:hover {
    border-color: var(--border-hi);
    background: var(--surface2);
    transform: translateY(-2px);
  }
  .cs-card.selected {
    border-color: var(--amber);
    background: rgba(212,144,58,0.06);
    box-shadow: 0 0 24px rgba(212,144,58,0.12);
  }
  .cs-card.selected::after {
    content: '✓ SELECTED';
    position: absolute; top: 10px; right: 10px;
    font-size: 9px; letter-spacing: 0.15em;
    color: var(--amber); font-family: 'JetBrains Mono', monospace;
  }
  .cs-champ-name {
    font-family: 'Teko', sans-serif;
    font-size: 28px; font-weight: 600;
    letter-spacing: 0.1em; line-height: 1;
    margin-bottom: 2px;
  }
  .cs-champ-title {
    font-size: 10px; color: var(--text-dim);
    letter-spacing: 0.12em; text-transform: uppercase;
    margin-bottom: 10px;
  }
  .cs-faction {
    font-size: 9px; letter-spacing: 0.15em;
    text-transform: uppercase; padding: 2px 7px;
    border: 1px solid currentColor; display: inline-block;
    margin-bottom: 14px;
  }
  .cs-stats {
    display: grid; grid-template-columns: 1fr 1fr;
    gap: 6px; margin-bottom: 14px;
  }
  .cs-stat {
    background: var(--surface2);
    border: 1px solid var(--border);
    padding: 5px 7px;
  }
  .cs-stat-label {
    font-size: 8px; color: var(--text-dim);
    letter-spacing: 0.12em; text-transform: uppercase;
    margin-bottom: 2px;
  }
  .cs-stat-val {
    font-family: 'Teko', sans-serif;
    font-size: 18px; font-weight: 500;
    line-height: 1; color: var(--text-bright);
  }
  .cs-passive {
    background: var(--surface2);
    border: 1px solid var(--border);
    padding: 8px 10px;
    margin-bottom: 8px;
  }
  .cs-passive-name {
    font-family: 'Teko', sans-serif;
    font-size: 13px; letter-spacing: 0.1em;
    color: var(--text-bright); margin-bottom: 3px;
  }
  .cs-passive-desc {
    font-size: 9px; line-height: 1.5; color: var(--text-dim);
  }
  .cs-ult-name {
    font-size: 9px; letter-spacing: 0.12em;
    color: var(--amber); text-transform: uppercase;
    margin-top: 10px;
  }
  .cs-ult-desc {
    font-size: 9px; color: var(--text-dim); margin-top: 2px; line-height: 1.4;
  }
  .cs-confirm-btn {
    padding: 14px 48px;
    background: transparent;
    border: 1px solid var(--amber);
    color: var(--amber);
    font-family: 'JetBrains Mono', monospace;
    font-size: 13px; letter-spacing: 0.2em;
    text-transform: uppercase; cursor: pointer;
    transition: all 0.2s;
  }
  .cs-confirm-btn:hover:not(:disabled) {
    background: rgba(212,144,58,0.1);
    box-shadow: 0 0 24px rgba(212,144,58,0.2);
  }
  .cs-confirm-btn:disabled {
    opacity: 0.3; cursor: not-allowed;
  }
  .cs-ai-label {
    font-size: 10px; letter-spacing: 0.15em;
    color: var(--text-dim); margin-bottom: 16px;
    text-transform: uppercase;
  }
  .ai-difficulty-row {
    display: flex; gap: 8px; margin-bottom: 36px;
  }
  .diff-btn {
    padding: 8px 20px;
    background: var(--surface);
    border: 1px solid var(--border);
    color: var(--text-dim);
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px; letter-spacing: 0.15em;
    text-transform: uppercase; cursor: pointer;
    transition: all 0.15s;
  }
  .diff-btn:hover { border-color: var(--border-hi); color: var(--text-bright); }
  .diff-btn.active { border-color: var(--amber); color: var(--amber); background: rgba(212,144,58,0.08); }

  /* ── Multiplayer Styles ─────────────────────────────────────────── */
  .mp-overlay {
    position: fixed; inset: 0; background: var(--bg); z-index: 600;
    display: flex; flex-direction: column; align-items: center;
    justify-content: flex-start; padding: 48px 24px; overflow-y: auto;
  }
  .mp-logo {
    font-family: 'Teko', sans-serif; font-size: 42px; font-weight: 700;
    letter-spacing: .3em; color: var(--amber); margin-bottom: 4px;
  }
  .mp-mode-tabs {
    display: flex; gap: 0; margin-bottom: 40px;
    border: 1px solid var(--border); overflow: hidden;
  }
  .mp-tab {
    padding: 10px 32px; font-family: 'JetBrains Mono', monospace;
    font-size: 11px; letter-spacing: .18em; text-transform: uppercase;
    cursor: pointer; border: none; background: var(--surface);
    color: var(--text-dim); transition: all 0.15s;
  }
  .mp-tab:hover { color: var(--text-bright); background: var(--surface2); }
  .mp-tab.active { background: rgba(212,144,58,0.12); color: var(--amber); }
  .mp-tab + .mp-tab { border-left: 1px solid var(--border); }
  .mp-panel {
    width: 520px; max-width: 96vw;
    background: var(--surface); border: 1px solid var(--border);
    padding: 28px 32px;
  }
  .mp-section-label {
    font-size: 9px; letter-spacing: .18em; color: var(--text-dim);
    text-transform: uppercase; margin-bottom: 10px;
  }
  .mp-input {
    width: 100%; padding: 10px 14px;
    background: var(--surface2); border: 1px solid var(--border);
    color: var(--text-bright); font-family: 'JetBrains Mono', monospace;
    font-size: 13px; letter-spacing: .05em; outline: none;
    transition: border-color 0.15s; margin-bottom: 8px;
  }
  .mp-input:focus { border-color: var(--amber); }
  .mp-input::placeholder { color: var(--text-dim); }
  .mp-btn {
    padding: 11px 28px; background: transparent;
    border: 1px solid var(--amber); color: var(--amber);
    font-family: 'JetBrains Mono', monospace; font-size: 12px;
    letter-spacing: .18em; text-transform: uppercase; cursor: pointer;
    transition: all 0.15s; width: 100%; margin-top: 8px;
  }
  .mp-btn:hover { background: rgba(212,144,58,0.1); }
  .mp-btn:disabled { opacity: 0.3; cursor: not-allowed; pointer-events: none; }
  .mp-btn.secondary {
    border-color: var(--border-hi); color: var(--text-dim);
  }
  .mp-btn.secondary:hover { color: var(--text-bright); border-color: var(--text-dim); }
  .mp-btn.danger { border-color: var(--danger); color: var(--danger); }
  .mp-divider {
    border: none; border-top: 1px solid var(--border);
    margin: 24px 0;
  }
  .mp-game-list { display: flex; flex-direction: column; gap: 8px; min-height: 60px; }
  .mp-game-item {
    display: flex; align-items: center; justify-content: space-between;
    padding: 12px 16px; background: var(--surface2); border: 1px solid var(--border);
    cursor: pointer; transition: border-color 0.15s;
  }
  .mp-game-item:hover { border-color: var(--border-hi); }
  .mp-game-item-info { display: flex; flex-direction: column; gap: 3px; }
  .mp-game-item-name {
    font-family: 'Teko', sans-serif; font-size: 18px; color: var(--text-bright);
    letter-spacing: .08em;
  }
  .mp-game-item-meta { font-size: 10px; color: var(--text-dim); letter-spacing: .1em; }
  .mp-game-item-badge {
    font-size: 9px; letter-spacing: .15em; text-transform: uppercase;
    padding: 3px 8px; border: 1px solid; font-family: 'JetBrains Mono', monospace;
  }
  .mp-game-item-badge.waiting { color: var(--amber); border-color: var(--amber-dim); }
  .mp-game-item-badge.your-turn { color: var(--success); border-color: var(--success); animation: pulse-pip 1.5s infinite; }
  .mp-game-item-badge.their-turn { color: var(--text-dim); border-color: var(--border); }
  .mp-game-item-badge.finished { color: var(--text-dim); border-color: var(--border); }
  .mp-status {
    font-size: 11px; letter-spacing: .12em; padding: 10px 14px;
    margin-top: 8px; text-align: center;
  }
  .mp-status.info { color: var(--amber); background: rgba(212,144,58,0.06); border: 1px solid var(--amber-dim); }
  .mp-status.error { color: var(--danger); background: rgba(192,64,64,0.06); border: 1px solid var(--danger); }
  .mp-status.success { color: var(--success); background: rgba(80,160,96,0.06); border: 1px solid var(--success); }
  .mp-waiting-pulse {
    display: inline-block; width: 8px; height: 8px; border-radius: 50%;
    background: var(--amber); margin-right: 8px;
    animation: pulse-pip 1.2s ease-in-out infinite;
  }
  .mp-invite-box {
    background: var(--surface2); border: 1px solid var(--border);
    padding: 12px 14px; font-size: 12px; color: var(--text-bright);
    letter-spacing: .04em; word-break: break-all; cursor: pointer;
    transition: border-color 0.15s; margin-bottom: 8px;
    font-family: 'JetBrains Mono', monospace;
  }
  .mp-invite-box:hover { border-color: var(--amber); }
  .mp-turn-banner {
    position: fixed; top: 0; left: 0; right: 0; z-index: 100;
    padding: 12px 24px; text-align: center;
    font-family: 'JetBrains Mono', monospace; font-size: 12px;
    letter-spacing: .15em; text-transform: uppercase;
    background: var(--surface); border-bottom: 1px solid var(--border);
    display: flex; align-items: center; justify-content: center; gap: 16px;
  }
  .mp-turn-banner.your-turn { border-color: var(--amber); color: var(--amber); }
  .mp-turn-banner.their-turn { border-color: var(--border-hi); color: var(--text-dim); }
  .mp-turn-banner.finished { border-color: var(--border); color: var(--text-dim); }
  .mp-spinner {
    display: inline-block; width: 12px; height: 12px;
    border: 2px solid var(--border); border-top-color: var(--amber);
    border-radius: 50%; animation: mp-spin 0.8s linear infinite;
  }
  @keyframes mp-spin { to { transform: rotate(360deg); } }
  .mp-hand-hidden-notice {
    background: var(--surface2); border: 1px solid var(--border);
    padding: 8px 12px; font-size: 10px; color: var(--text-dim);
    letter-spacing: .12em; text-align: center; text-transform: uppercase;
    margin-bottom: 6px;
  }
  .mp-config-note {
    background: rgba(212,144,58,0.06); border: 1px solid var(--amber-dim);
    padding: 16px 20px; font-size: 11px; color: var(--text);
    line-height: 1.7; letter-spacing: .04em;
  }
  .mp-config-note strong { color: var(--amber); }
  .mp-config-note code {
    font-family: 'JetBrains Mono', monospace; font-size: 10px;
    background: var(--surface2); padding: 2px 6px; color: var(--text-bright);
  }
</style>
</head>
<body>

<header>
  <div class="logo">CORR<span>.</span>IDORS</div>
  <div class="header-meta">
    <span id="header-phase" class="phase-display phase-draw">
      <span class="phase-dot"></span>DRAW
    </span>
    <div class="turn-badge" id="header-turn">TURN 1</div>
    <span id="header-winner" style="display:none; color:var(--amber); font-family:'Teko',sans-serif; font-size:16px; letter-spacing:0.2em;"></span>
    <button onclick="showMultiplayerLobby()" style="
      padding:5px 14px; background:transparent; border:1px solid var(--border-hi);
      color:var(--text-dim); font-family:'JetBrains Mono',monospace; font-size:10px;
      letter-spacing:.15em; text-transform:uppercase; cursor:pointer;
      transition:all 0.15s;
    " onmouseover="this.style.color='var(--amber)';this.style.borderColor='var(--amber)'"
       onmouseout="this.style.color='var(--text-dim)';this.style.borderColor='var(--border-hi)'">
      ⟳ ASYNC PvP
    </button>
  </div>
</header>

<main>
  <!-- Player 0 Panel -->
  <div class="panel" id="panel-p0">
    <div class="panel-label">PLAYER 0</div>
    <div class="champion-card">
      <div class="champion-name" id="p0-name" style="color:var(--p0)">—</div>
      <div class="champion-title" id="p0-title">Select Champion</div>
      <div class="faction-badge faction-Architects" id="p0-faction">Architects</div>
      <div class="stats-grid">
        <div class="stat">
          <div class="stat-label">WALLS</div>
          <div class="stat-value" id="p0-walls">0/5</div>
        </div>
        <div class="stat">
          <div class="stat-label">HAND</div>
          <div class="stat-value" id="p0-hand-count">0/4</div>
        </div>
        <div class="stat">
          <div class="stat-label">SPEED</div>
          <div class="stat-value" id="p0-speed">1</div>
        </div>
        <div class="stat">
          <div class="stat-label">OPENING</div>
          <div class="stat-value" id="p0-draw">2</div>
        </div>
      </div>
      <div class="wall-count" id="p0-wall-pips"></div>
    </div>
    <div class="ultimate-section">
      <div class="ultimate-label">ULTIMATE</div>
      <div class="ultimate-name" id="p0-ult-name">The Grand Design</div>
      <div class="charge-bar" id="p0-charge-bar"></div>
      <div class="charge-text" id="p0-charge-text">0 / 5 charges</div>
      <button class="action-btn" id="p0-ult-btn" onclick="activateUltimate(0)"
        style="width:100%;margin-top:6px;opacity:0.3;pointer-events:none;font-size:10px;padding:5px 8px"
        disabled>⚡ ULTIMATE READY</button>
    </div>
    <div class="passive-section">
      <div class="passive-name" id="p0-passive-name">Fortified Ground</div>
      <div class="passive-desc" id="p0-passive-desc">Vael's walls require 2 Demolish effects to destroy.</div>
    </div>
    <div id="p0-status" class="status-effects"></div>
    <div class="hand-section">
      <div class="hand-label">HAND <span id="p0-deck-count" style="color:var(--text-dim)">(deck: 15)</span></div>
      <div class="hand-cards" id="p0-hand"></div>
    </div>
  </div>

  <!-- Board Area -->
  <div class="board-area" id="board-area">
    <div class="turn-banner p0" id="turn-banner">PLAYER 0 — DRAW PHASE</div>

    <!-- Draw screen overlay (shown between turns) -->
    <div class="draw-screen" id="draw-screen" style="display:none">
      <div class="draw-screen-subtitle">HAND OFF DEVICE TO</div>
      <div class="draw-screen-name" id="draw-screen-name" style="color:var(--p0)">PLAYER 0</div>
      <div style="font-size:11px; color:var(--text-dim); letter-spacing:0.12em;">When ready, draw your hand</div>
      <button class="draw-screen-btn" id="draw-screen-btn">DRAW HAND →</button>
    </div>

    <div id="board-container" style="position:relative;">
      <!-- Board grid + wall layers built by JS -->
    </div>

    <div class="action-bar" id="action-bar">
      <button class="action-btn primary" id="btn-move" onclick="enterMoveMode()">MOVE</button>

      <button class="action-btn danger" id="btn-end" onclick="endTurnHuman()">END TURN</button>
    </div>

    <div class="mode-indicator" id="mode-indicator">Select an action above</div>

    <!-- Log -->
    <div class="log-section" style="width:100%">
      <div class="panel-label" style="margin-bottom:8px">GAME LOG</div>
      <div class="log-scroll" id="game-log"></div>
    </div>
  </div>

  <!-- Player 1 Panel -->
  <div class="panel right" id="panel-p1">
    <div class="panel-label">PLAYER 1</div>
    <div class="champion-card">
      <div class="champion-name" id="p1-name" style="color:var(--p1)">—</div>
      <div class="champion-title" id="p1-title">AI Opponent</div>
      <div class="faction-badge faction-Architects" id="p1-faction">Architects</div>
      <div class="stats-grid">
        <div class="stat">
          <div class="stat-label">WALLS</div>
          <div class="stat-value" id="p1-walls">0/2</div>
        </div>
        <div class="stat">
          <div class="stat-label">HAND</div>
          <div class="stat-value" id="p1-hand-count">0/4</div>
        </div>
        <div class="stat">
          <div class="stat-label">SPEED</div>
          <div class="stat-value" id="p1-speed">1</div>
        </div>
        <div class="stat">
          <div class="stat-label">OPENING</div>
          <div class="stat-value" id="p1-draw">4</div>
        </div>
      </div>
      <div class="wall-count" id="p1-wall-pips"></div>
    </div>
    <div class="ultimate-section">
      <div class="ultimate-label">ULTIMATE</div>
      <div class="ultimate-name" id="p1-ult-name">Lockdown</div>
      <div class="charge-bar" id="p1-charge-bar"></div>
      <div class="charge-text" id="p1-charge-text">0 / 3 charges</div>
      <button class="action-btn" id="p1-ult-btn" onclick="activateUltimate(1)"
        style="width:100%;margin-top:6px;opacity:0.3;pointer-events:none;font-size:10px;padding:5px 8px"
        disabled>⚡ ULTIMATE READY</button>
    </div>
    <div class="passive-section">
      <div class="passive-name" id="p1-passive-name">Stonework</div>
      <div class="passive-desc" id="p1-passive-desc">Your walls can be placed touching existing walls.</div>
    </div>
    <div id="p1-status" class="status-effects"></div>
    <div class="hand-section">
      <div class="hand-label">HAND <span id="p1-deck-count" style="color:var(--text-dim)">(deck: 15)</span></div>
      <div class="hand-cards" id="p1-hand"></div>
    </div>
  </div>
</main>

<!-- Victory overlay -->
<div class="victory-overlay" id="victory-overlay" style="display:none">
  <div class="victory-card">
    <div class="victory-title" id="victory-title" style="color:var(--amber)">P0 WINS</div>
    <div class="victory-subtitle" id="victory-subtitle">Reached the goal line</div>
    <div class="victory-stats" id="victory-stats">
      <div class="victory-stat">
        <div class="victory-stat-label">TURNS</div>
        <div class="victory-stat-value" id="v-turns">—</div>
      </div>
      <div class="victory-stat">
        <div class="victory-stat-label">WALLS PLACED</div>
        <div class="victory-stat-value" id="v-walls">—</div>
      </div>
    </div>
    <button class="draw-screen-btn" onclick="resetGame()">NEW GAME</button>
  </div>
</div>

<!-- Debug overlay -->
<div id="debug-overlay">
  <div class="debug-title">⌗ DEBUG — OMNISCIENT VIEW</div>
  <pre id="debug-content" style="white-space:pre-wrap;word-break:break-all;"></pre>
</div>


<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
<script>
// ═══════════════════════════════════════════════════════════════════
// CORRIDORS UI — Phase 2
// Self-contained engine + UI in a single file.
// Engine is a simplified inline version that mirrors the TypeScript
// structures exactly — ready to be swapped for the compiled engine.
// ═══════════════════════════════════════════════════════════════════

const BOARD_SIZE = 9;
const CELL = 52;
const GAP  = 3;

// ── Faction rules — 5 factions, all: 1 card + 1 move per turn ──────
const FACTION_RULES = {
  Architects:  { cardPlays:1, moveAllowed:true, cardOrMove:false, baseSpeed:1 },
  Pathfinders: { cardPlays:1, moveAllowed:true, cardOrMove:false, baseSpeed:1 },
  Wardens:     { cardPlays:1, moveAllowed:true, cardOrMove:false, baseSpeed:1 },
  Phantoms:    { cardPlays:1, moveAllowed:true, cardOrMove:false, baseSpeed:1 },
  Adepts:      { cardPlays:1, moveAllowed:true, cardOrMove:false, baseSpeed:1 },
};

const FACTION_COUNTER = {
  Architects:  'Wardens',     // Eviction/repositioning undoes careful maze-building
  Pathfinders: 'Architects',  // Dense walls stop rushers
  Wardens:     'Phantoms',    // Illusions disrupt control plans
  Phantoms:    'Pathfinders', // Speed blows through phantom bluffs
  Adepts:      'Wardens',     // Disruption control counters hybrid flexibility
};

// Faction AI modifiers
const FACTION_AI = {
  Architects:  { moveBonus: 0,  wallBonus: 4,  aggression: 0.7, control: 1.4 },
  Pathfinders: { moveBonus: 4,  wallBonus: 0,  aggression: 1.6, control: 0.5 },
  Wardens:     { moveBonus:-1,  wallBonus: 2,  aggression: 0.5, control: 1.8 },
  Phantoms:    { moveBonus: 1,  wallBonus: 3,  aggression: 0.9, control: 1.1 },
  Adepts:      { moveBonus: 1,  wallBonus: 2,  aggression: 1.0, control: 1.2 },
};

// ── Champions (5 — one per faction, per GDD v2.4) ───────────────────
const CHAMPIONS = {
  // Architects: maze-building, indestructible walls, double-card passive
  magnus: {
    id:'magnus', name:'Magnus', title:'Stoneweaver', faction:'Architects',
    wallLimit:10, handSize:6, cardDraw:3, moveSpeed:1,
    ultimateCost:5, ultimateName:'Living Blueprint',
    passiveName:'Master Mason',
    passiveDesc:'Each turn you may play a 2nd Wall card instead of moving.',
    ultimateDesc:'Discard your hand and refill to full hand size immediately.',
  },

  // Pathfinders: speed, mobility, racing
  soren: {
    id:'soren', name:'Soren', title:'Swiftstride', faction:'Pathfinders',
    wallLimit:7, handSize:4, cardDraw:2, moveSpeed:1,
    ultimateCost:5, ultimateName:'Stormpath',
    passiveName:'Fleetfoot',
    passiveDesc:'Each turn you may take a 2nd move instead of playing a card.',
    ultimateDesc:'Ignore all walls for this entire turn — move freely through them.',
  },

  // Wardens: disruption, hand control, wall repositioning
  thorne: {
    id:'thorne', name:'Thorne', title:'the Lockmaster', faction:'Wardens',
    wallLimit:5, handSize:5, cardDraw:4, moveSpeed:1,
    ultimateCost:7, ultimateName:'Total Reordering',
    passiveName:"Warden's Stare",
    passiveDesc:"Opponent's hand is always revealed to you.",
    ultimateDesc:'Reposition ALL walls on the board to legal locations of your choice.',
  },

  // Phantoms: illusions, bluffing, misdirection
  nyx: {
    id:'nyx', name:'Nyx', title:'the Mirage', faction:'Phantoms',
    wallLimit:7, handSize:5, cardDraw:3, moveSpeed:1,
    ultimateCost:3, ultimateName:'Veil of Shadows',
    passiveName:'Illusory Trail',
    passiveDesc:'When you move, a phantom duplicate marker lingers on your previous position for 1 turn.',
    ultimateDesc:'Your champion becomes invisible to opponent for 3 full turns.',
  },

  // Adepts: hybrid, cross-faction, flexible
  elara: {
    id:'elara', name:'Elara', title:'the Weaver', faction:'Adepts',
    wallLimit:8, handSize:6, cardDraw:4, moveSpeed:1,
    ultimateCost:4, ultimateName:'Faction Forge',
    passiveName:'Omni-Arsenal',
    passiveDesc:'Your deck may include cards from any faction. Draw 1 extra card when you play cards from two different categories in a single turn.',
    ultimateDesc:'Generate 3 random faction cards (one from 3 different factions); play one immediately for free.',
  },
};

// ── Cards — GDD v2.4 ─────────────────────────────────────────────────
const CARDS = {

  // ── BASIC CARD POOL (Universal) ──────────────────────────────────────
  BB: { id:'BB', name:'Basic Barrier',    faction:'Basic', rarity:'Common',   type:'Wall',
        desc:'Place a 2-tile straight wall (H or V). Permanent.', wallLen:2 },
  CB: { id:'CB', name:'Corner Block',     faction:'Basic', rarity:'Common',   type:'Wall',
        desc:'Place an L-shaped 2-tile wall. Permanent.', wallLen:2, special:'cornerPiece' },
  RC: { id:'RC', name:'Reconstruction',   faction:'Basic', rarity:'Common',   type:'Disruption',
        desc:'Remove one of your own walls anywhere on the board. Draw 1 card.' },
  AV: { id:'AV', name:'Advance',          faction:'Basic', rarity:'Common',   type:'Movement',
        desc:'Gain +1 orthogonal move this turn. Cannot pass walls.' },
  QS: { id:'QS', name:'Quick Step',       faction:'Basic', rarity:'Uncommon', type:'Movement',
        desc:'Gain +1 diagonal move this turn. Cannot pass walls.', overrideSpeed:2 },
  SW: { id:'SW', name:'Swift Leap',       faction:'Basic', rarity:'Uncommon', type:'Movement',
        desc:'Gain +1 move and may jump over the opponent this turn.', overrideSpeed:2 },
  WS: { id:'WS', name:'Wind Sprint',      faction:'Basic', rarity:'Rare',     type:'Movement',
        desc:'Gain +2 orthogonal moves this turn. May pass through walls you own.', overrideSpeed:3 },

  // ── ARCHITECTS ───────────────────────────────────────────────────────
  AR1: { id:'AR1', name:'Reinforced Slab',  faction:'Architects', rarity:'Common',   type:'Wall',
         desc:'Place a 2-tile indestructible wall (H or V). Permanent. Cannot be destroyed or moved.', wallLen:2, reinforced:true },
  AR2: { id:'AR2', name:'Reinforce Wall',   faction:'Architects', rarity:'Common',   type:'Disruption',
         desc:'Choose one of your walls and reinforce it — it cannot be destroyed or moved by the opponent.' },
  AR3: { id:'AR3', name:'Blueprint Shift',  faction:'Architects', rarity:'Uncommon', type:'Disruption',
         desc:'Move one of your non-reinforced walls to any legal location on the board.' },
  AR4: { id:'AR4', name:'Grand Bastion',    faction:'Architects', rarity:'Rare',     type:'Wall',
         desc:'Place a 3-tile straight wall. Permanent.', wallLen:3 },
  AR5: { id:'AR5', name:'Labyrinth Core',   faction:'Architects', rarity:'Legendary',type:'Wall',
         desc:'Place a 4-tile straight wall. All your walls adjacent to it gain Reinforce.', wallLen:4, reinforced:true },

  // ── PATHFINDERS ──────────────────────────────────────────────────────
  PF1: { id:'PF1', name:'Momentum',     faction:'Pathfinders', rarity:'Common',   type:'Movement',
         desc:'Gain +2 orthogonal moves this turn.', overrideSpeed:3 },
  PF2: { id:'PF2', name:'Leap',         faction:'Pathfinders', rarity:'Common',   type:'Movement',
         desc:'Gain +1 move and may jump over the opponent even if not adjacent.', overrideSpeed:2 },
  PF3: { id:'PF3', name:'Shortcut',     faction:'Pathfinders', rarity:'Uncommon', type:'Movement',
         desc:'Move up to 3 spaces this turn ignoring diagonal restrictions.', overrideSpeed:3 },
  PF4: { id:'PF4', name:'Eternal Path', faction:'Pathfinders', rarity:'Rare',     type:'Movement',
         desc:'Move up to 4 spaces this turn.', overrideSpeed:4 },
  PF5: { id:'PF5', name:'Wall Vault',   faction:'Pathfinders', rarity:'Uncommon', type:'Movement',
         desc:'Move up to 2 spaces this turn and may pass through one wall of any kind.', overrideSpeed:2, tunnelThrough:true },

  // ── WARDENS ──────────────────────────────────────────────────────────
  WD1: { id:'WD1', name:'Binding Wall',   faction:'Wardens', rarity:'Common',   type:'Wall',
         desc:'Place a 1-tile Binding Wall. If the opponent ends their turn adjacent to it, they skip their move action next turn (may still play a card).', wallLen:1, binding:true },
  WD2: { id:'WD2', name:'Tax Notice',     faction:'Wardens', rarity:'Common',   type:'Disruption',
         desc:'If the opponent has 3+ walls in play, they must discard 1 card of your choice. Draw 1 card.' },
  WD3: { id:'WD3', name:'Eviction',       faction:'Wardens', rarity:'Uncommon', type:'Disruption',
         desc:'Move 1 non-reinforced opponent wall to any legal location on the board. The opponent cannot respond.' },
  WD4: { id:'WD4', name:'Confiscate',          faction:'Wardens', rarity:'Rare',     type:'Disruption',
         desc:"Force the opponent to discard 2 random cards from their hand." },
  WD5: { id:'WD5', name:'Total Seizure',        faction:'Wardens', rarity:'Legendary',type:'Disruption',
         desc:'Move ALL opponent walls currently on the board to any legal locations of your choice. Reinforced walls are not exempt.' },
  WD6: { id:'WD6', name:'Condemned Passage',    faction:'Wardens', rarity:'Rare',     type:'Wall',
         desc:'Place a 2-tile Binding Wall. Permanent. The opponent cannot jump over it — jump movement through this wall is blocked entirely.', wallLen:2, binding:true, noJump:true },

  // ── PHANTOMS ─────────────────────────────────────────────────────────
  PH1: { id:'PH1', name:'Phantom Wall',  faction:'Phantoms', rarity:'Common',   type:'Wall',
         desc:'Place a phantom wall. Appears as a real 2-tile wall to the opponent. Both players can walk through it freely — doing so removes it immediately and frees the wall slot.', wallLen:2, phantom:true },
  PH2: { id:'PH2', name:'Compel',        faction:'Phantoms', rarity:'Uncommon', type:'Disruption',
         desc:'Force the opponent\'s champion to move 1 space in a direction of your choice. This is not voluntary movement — Phantom Walls are not removed by this.' },
  PH3: { id:'PH3', name:'Echo Strike',   faction:'Phantoms', rarity:'Uncommon', type:'Wall',
         desc:'Place a Phantom Wall on your side of the board and simultaneously place a real mirrored wall on the opponent\'s side at no extra cost.', wallLen:2, phantom:true, special:'echoStrike' },
  PH4: { id:'PH4', name:'Veil Lattice',  faction:'Phantoms', rarity:'Rare',     type:'Wall',
         desc:'Place 2 Phantom Walls anywhere on the board. These Phantom Walls do not expire automatically — they persist until walked through voluntarily.', wallLen:2, phantom:true, special:'veilLattice' },
  PH5: { id:'PH5', name:'Compel Storm',  faction:'Phantoms', rarity:'Rare',     type:'Disruption',
         desc:'Force the opponent\'s champion to move up to 3 spaces in directions of your choice. Real walls block individual steps. Phantom Walls do not trigger removal.' },

  // ── ADEPTS ───────────────────────────────────────────────────────────
  AD1: { id:'AD1', name:'Flexible Form',  faction:'Adepts', rarity:'Common',   type:'Movement',
         desc:'Gain +1 orthogonal move this turn. If you also played a Wall card this turn, draw 1 card (Equilibrium).', overrideSpeed:2 },
  AD2: { id:'AD2', name:'Adaptive Block', faction:'Adepts', rarity:'Common',   type:'Wall',
         desc:'Place a 1-tile wall (H or V). If you also moved your champion this turn, wall becomes 2 tiles (extended in direction of your choice).', wallLen:1, special:'adaptiveBlock' },
  AD3: { id:'AD3', name:'Resonant Burst', faction:'Adepts', rarity:'Uncommon', type:'Movement',
         desc:'+1 move per different card category played this turn (Wall/Disruption/Movement each count once). Minimum +1.', overrideSpeed:2, reactive:true },
  AD4: { id:'AD4', name:'Faction Mirror', faction:'Adepts', rarity:'Rare',     type:'Disruption',
         desc:'Copy the last card your opponent played. If it was a Wall card, the wall belongs to you.' },
  AD5: { id:'AD5', name:'Synthesis Wall', faction:'Adepts', rarity:'Rare',     type:'Wall',
         desc:'Place a 2-tile wall. If you have played both a Movement and a Disruption card this turn, the wall gains Reinforce.', wallLen:2 },
};

function getCardWallLength(cardId) {
  return CARDS[cardId]?.wallLen || 2;
}

function shuffle(arr) {
  const a = [...arr];
  for (let i = a.length-1; i > 0; i--) {
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}

// GDD-accurate starter decks per faction
function buildStarterDeck(faction) {
  const deckDefs = {
    Architects:  ['BB','BB','BB','AR1','AR1','AR2','AR3','AR4','RC','RC'],
    Pathfinders: ['BB','BB','BB','RC','RC','QS','QS','SW','SW','WS'],
    Wardens:     ['BB','BB','RC','WD1','WD1','WD2','WD3','WD3','WD4','WD6'],
    Phantoms:    ['BB','BB','BB','PH1','PH1','PH1','RC','PH2','PH2','PH4'],
    Adepts:      ['AD1','AD1','AD2','AD2','AD3','AD4','BB','PF1','WD3','PH1'],
  };
  const ids = deckDefs[faction] || deckDefs['Architects'];
  // 10-card deck — no doubling
  const base = ids.map(id => ({...CARDS[id]}));
  return shuffle([...base]);
}



// ── State ───────────────────────────────────────────────────────────
let gameState = null;
let uiMode = 'idle';       // 'idle' | 'move' | 'wall' | 'wallPick' | 'wallRedirect' | 'wallSeal' | 'wallPunch' | 'wallReinforce' | 'wallReconstruct'
let wallOrientation = 'H';
let selectedCard = null;   // {id, idx, length, isPhantom, isDurable} or null
let hasMoved = false;       // whether champion has moved this turn
let hasPlayedCard = false;  // whether a card has been played this turn
let selectedChampionId = null;
let aiDifficulty = 'medium'; // 'easy' | 'medium' | 'hard'
const DIFFICULTY_DEPTH = { easy: 0, medium: 1, hard: 2 };

// isTurnDone — defined in card system section below
let debugVisible = false;
const AI_PLAYER = 1;       // Player 1 is always the AI
let aiThinking = false;

// ── createPlayer ────────────────────────────────────────────────────
function createPlayer(index, championId, faction) {
  const def = CHAMPIONS[championId];
  return {
    index,
    champion: { ...def },
    position: index === 0 ? {row:8, col:4} : {row:0, col:4},
    deck: buildStarterDeck(faction),
    hand: [],
    discard: [],
    wallsInPlay: 0,
    wallLimitCurrent: def.wallLimit,
    ultimateCharge: 0,
    ultimateReady: false,
    ultimateUsed: false,
    statusEffects: [],
    positionHidden: false,
  };
}

// ── initGame ────────────────────────────────────────────────────────
function initGame(playerChampId, aiChampId) {
  playerChampId = playerChampId || 'magnus';
  aiChampId     = aiChampId     || 'soren';
  const pChamp  = CHAMPIONS[playerChampId];
  const aChamp  = CHAMPIONS[aiChampId];
  gameState = {
    players: [
      createPlayer(0, playerChampId, pChamp.faction),
      createPlayer(1, aiChampId,     aChamp.faction),
    ],
    walls: [],
    decoyTokens: [],
    trapTokens: [],
    activePlayer: 0,
    turnNumber: 1,
    phase: 'draw',
    winner: null,
    log: [],
    nextWallId: 1,
    nextTokenId: 1,
    firstDraw: [true, true],  // both players get full opening hand on first draw
  };
  // Randomize who goes first
  const firstPlayer = Math.random() < 0.5 ? 0 : 1;
  gameState.activePlayer = firstPlayer;

  uiMode = 'idle';
  selectedCard = null;
  hasMoved = false;
  hasPlayedCard = false;
  aiThinking = false;
  aiProbedWallIds.clear();
  renderAll();
  // Draw player 0's opening hand automatically
  const _pName = gameState.players[0].champion.name;
  const _aName = gameState.players[1].champion.name;
  addLog(0, 'system', `Game started. You (${_pName}) vs AI (${_aName}).`);
  performDraw();
}

// ── BFS pathfinding ─────────────────────────────────────────────────
function edgeKey(a, b) {
  const ka = `${a.row},${a.col}`, kb = `${b.row},${b.col}`;
  return ka < kb ? `${ka}|${kb}` : `${kb}|${ka}`;
}

function wallEdges(wall) {
  const edges = [];
  const {anchor, orientation, length} = wall;
  for (let i = 0; i < length; i++) {
    if (orientation === 'H') {
      edges.push({a:{row:anchor.row, col:anchor.col+i}, b:{row:anchor.row+1, col:anchor.col+i}});
    } else {
      edges.push({a:{row:anchor.row+i, col:anchor.col}, b:{row:anchor.row+i, col:anchor.col+1}});
    }
  }
  return edges;
}

function buildBlockedEdges(walls, moverPi) {
  // moverPi: the moving player's index.
  // Phantom walls block opponent movement; owner passes through own phantoms freely.
  // When moverPi is undefined (BFS path-guarantee checks), phantoms are ignored.
  const blocked = new Set();
  for (const wall of walls) {
    if (wall.isPhantom) {
      if (moverPi === undefined) continue;       // path checks ignore phantoms
      if (wall.owner === moverPi) continue;      // owner moves freely through own phantoms
      // Opponent's phantom: block the mover
    }
    for (const e of wallEdges(wall)) blocked.add(edgeKey(e.a, e.b));
  }
  return blocked;
}

function isEdgeBlocked(from, to, blocked) {
  return blocked.has(edgeKey(from, to));
}

function bfsDistance(from, goalRow, walls) {
  const blocked = buildBlockedEdges(walls);
  const visited = new Set();
  const queue = [[from, 0]];
  visited.add(`${from.row},${from.col}`);
  const dirs = [{r:-1,c:0},{r:1,c:0},{r:0,c:1},{r:0,c:-1}];
  while (queue.length) {
    const [cur, dist] = queue.shift();
    if (cur.row === goalRow) return dist;
    for (const d of dirs) {
      const nb = {row:cur.row+d.r, col:cur.col+d.c};
      if (nb.row<0||nb.row>=BOARD_SIZE||nb.col<0||nb.col>=BOARD_SIZE) continue;
      const k = `${nb.row},${nb.col}`;
      if (visited.has(k)) continue;
      if (isEdgeBlocked(cur, nb, blocked)) continue;
      visited.add(k);
      queue.push([nb, dist+1]);
    }
  }
  return Infinity;
}

function hasPath(from, goalRow, walls) {
  return bfsDistance(from, goalRow, walls) < Infinity;
}

// ── Legal moves ─────────────────────────────────────────────────────
function getLegalMoves(state, pIdx, overrideSpeed) {
  const player = state.players[pIdx];
  const opponent = state.players[pIdx === 0 ? 1 : 0];
  // Stormpath: ignore all walls this turn
  const effectiveWalls = player.stormpath ? [] : state.walls;
  const blocked = buildBlockedEdges(effectiveWalls, pIdx);
  const pos = player.position;
  const speed = (overrideSpeed !== undefined && overrideSpeed !== null) ? overrideSpeed : player.champion.moveSpeed;
  const opPos = opponent.position;
  const key = p => `${p.row},${p.col}`;
  const dirs = [{r:-1,c:0},{r:1,c:0},{r:0,c:1},{r:0,c:-1}];

  const visited = new Set([key(pos)]);
  let frontier = [pos];
  const reachable = [];

  for (let step = 0; step < speed; step++) {
    const nextFrontier = [];
    for (const cur of frontier) {
      for (const d of dirs) {
        const nb = {row:cur.row+d.r, col:cur.col+d.c};
        if (nb.row<0||nb.row>=BOARD_SIZE||nb.col<0||nb.col>=BOARD_SIZE) continue;
        const k = key(nb);
        if (visited.has(k)) continue;
        if (k === key(opPos)) continue;   // can't land on opponent
        if (isEdgeBlocked(cur, nb, blocked)) continue;
        visited.add(k);
        nextFrontier.push(nb);
        reachable.push(nb);
      }
    }
    frontier = nextFrontier;
  }

  // Jump rules when directly adjacent to opponent
  const dr = opPos.row - pos.row, dc = opPos.col - pos.col;
  const adjacent = (Math.abs(dr)===1 && dc===0) || (dr===0 && Math.abs(dc)===1);
  // Check for Condemned Passage (noJump) walls blocking the jump path
  const noJumpWalls = state.walls.filter(w => w.noJump && !w.isPhantom);
  const jumpBlockedByCondemnedPassage = noJumpWalls.some(w =>
    wallEdges(w).some(e => edgeKey(e.a, e.b) === edgeKey(pos, opPos))
  );
  if (adjacent && !isEdgeBlocked(pos, opPos, blocked) && !jumpBlockedByCondemnedPassage) {
    const straight = {row: opPos.row+dr, col: opPos.col+dc};
    const straightInBounds = straight.row>=0&&straight.row<BOARD_SIZE&&straight.col>=0&&straight.col<BOARD_SIZE;
    if (straightInBounds && !isEdgeBlocked(opPos, straight, blocked)) {
      if (!visited.has(key(straight))) reachable.push(straight);
    } else {
      const diags = dr===0
        ? [{row:opPos.row-1,col:opPos.col},{row:opPos.row+1,col:opPos.col}]
        : [{row:opPos.row,col:opPos.col-1},{row:opPos.row,col:opPos.col+1}];
      for (const d of diags) {
        if (d.row<0||d.row>=BOARD_SIZE||d.col<0||d.col>=BOARD_SIZE) continue;
        if (!isEdgeBlocked(opPos, d, blocked) && !visited.has(key(d))) reachable.push(d);
      }
    }
  }

  return reachable;
}

// ── Wall validation ─────────────────────────────────────────────────
function wallInBounds(anchor, orientation, length) {
  if (orientation === 'H')
    return anchor.row>=0 && anchor.row<BOARD_SIZE-1 && anchor.col>=0 && anchor.col+length<=BOARD_SIZE;
  return anchor.col>=0 && anchor.col<BOARD_SIZE-1 && anchor.row>=0 && anchor.row+length<=BOARD_SIZE;
}

function wallsConflict(a, b) {
  if (a.isPhantom || b.isPhantom) return false;
  const edgesA = new Set(wallEdges(a).map(e => edgeKey(e.a, e.b)));
  for (const e of wallEdges(b)) {
    if (edgesA.has(edgeKey(e.a, e.b))) return true;
  }
  // Cross check for length-2 walls
  if (a.orientation !== b.orientation && a.length===2 && b.length===2) {
    const h = a.orientation==='H'?a:b, v = a.orientation==='V'?a:b;
    if (h.anchor.row===v.anchor.row && h.anchor.col===v.anchor.col) return true;
  }
  return false;
}

function isWallLegal(anchor, orientation, length, walls, p0pos, p1pos, isPhantom=false) {
  if (!wallInBounds(anchor, orientation, length)) return false;
  // Can't overlap with existing real walls
  const proposed = {id:'__test__',owner:0,anchor,orientation,length,isPhantom:false,durable:false,durableHits:0,immune:false,reinforced:false,temporary:false,turnsRemaining:null,placedOnTurn:0};
  for (const w of walls) {
    if (!w.isPhantom && wallsConflict(proposed, w)) return false;
  }
  if (isPhantom) {
    // Phantom walls: must not cut off EITHER player's path (same rule as real walls).
    // The opponent can walk through them (removing them), but at placement time
    // the board must still have a valid path for both players treating the phantom as real.
    const proposed = {id:'__phantom_test__',owner:0,anchor,orientation,length,isPhantom:false,durable:false,durableHits:0,immune:false,temporary:false,turnsRemaining:null,placedOnTurn:0};
    const afterReal = [...walls.filter(w => !w.isPhantom), proposed];
    return hasPath(p0pos, 0, afterReal) && hasPath(p1pos, BOARD_SIZE - 1, afterReal);
  }
  const after = [...walls, proposed];
  return hasPath(p0pos, 0, after) && hasPath(p1pos, 8, after);
}

// ── State mutations ─────────────────────────────────────────────────
function performDraw() {
  const pi = gameState.activePlayer;
  const p = gameState.players[pi];

  // First draw: fill to handSize. Subsequent turns: draw 1, but only if
  // hand is below max. Never draw when at or above handSize.
  const isFirst = !!gameState.firstDraw[pi];
  const maxHand = p.champion.handSize;

  let deck = [...p.deck], discard = [...p.discard];
  const drawn = [];

  if (isFirst) {
    gameState.firstDraw[pi] = false;
    // Opening hand = cardDraw cards (not full handSize)
    const need = Math.min(p.champion.cardDraw, Math.max(0, maxHand - p.hand.length));
    for (let i = 0; i < need; i++) {
      if (!deck.length) {
        if (!discard.length) break;
        deck = shuffle([...discard]); discard = [];
      }
      drawn.push(deck.shift());
    }
  } else {
    // Subsequent turns: always draw exactly 1 card (if hand not full)
    const drawCount = Math.min(1, Math.max(0, maxHand - p.hand.length));
    for (let i = 0; i < drawCount; i++) {
      if (!deck.length && discard.length) { deck = shuffle([...discard]); discard = []; }
      if (deck.length) drawn.push(deck.shift());
    }
  }

  const newHand = [...p.hand, ...drawn];
  gameState.players[pi] = {...p, deck, discard, hand: newHand};
  if (drawn.length) addLog(pi, 'draw', `Drew ${drawn.length}: ${drawn.filter(x=>x&&x.name).map(c=>c.name).join(', ')}`);

  gameState.phase = 'action';
  hasMoved = false;
  hasPlayedCard = false;
  renderAll();
  showStatus(pi===AI_PLAYER ? 'AI is thinking...' : 'Your turn — MOVE or play a card', pi===AI_PLAYER ? '' : 'active');

  // AI's turn
  if (pi === AI_PLAYER) {
    aiThinking = true;
    setTimeout(runAI, 600);
  }
}

function executeMove(to) {
  const pi   = gameState.activePlayer;
  const from = gameState.players[pi].position;
  addLog(pi, 'move', `Moved (${from.row},${from.col}) → (${to.row},${to.col})`);
  // If a movement card was pending, resolve it now (discard + count)
  if (selectedCard && selectedCard._pendingMove) {
    // Find the card in hand — idx may have shifted, so search by ID as fallback
    let discardIdx = selectedCard.idx;
    if (discardIdx >= 0 && discardIdx < gameState.players[pi].hand.length &&
        gameState.players[pi].hand[discardIdx]?.id === selectedCard.id) {
      // idx still valid and matches
    } else {
      // idx stale — find first card with matching ID
      discardIdx = gameState.players[pi].hand.findIndex(c => c.id === selectedCard.id);
    }
    const mc = discardIdx >= 0 ? gameState.players[pi].hand[discardIdx] : null;
    if (mc) discardCard(pi, discardIdx);
    countCardPlayed(pi);
    addLog(pi, 'card', 'Played: ' + (mc ? mc.name : 'movement card') + ' (speed ' + (selectedCard.overrideSpeed||1) + ')');
  }
  // Re-read state after potential discard mutation, then update position
  gameState.players[pi] = {...gameState.players[pi], position: to};
  // Clear stormpath after move (one-turn effect)
  if (gameState.players[pi].stormpath) {
    gameState.players[pi] = {...gameState.players[pi], stormpath: false};
    countCardPlayed(pi); // counts the ultimate usage
  }
  hasMoved = true;
  uiMode = 'idle';
  selectedCard = null;

  // ── Phantom wall walk-through detection ──────────────────────────────
  // When a player VOLUNTARILY moves through a phantom wall edge, remove that phantom
  // immediately and decrement the owner's wall count.
  // This applies to both the phantom's owner AND the opponent who chose to call the bluff.
  const crossedPhantoms = gameState.walls.filter(w => {
    if (!w.isPhantom) return false;
    // Check if the move from `from` to `to` crossed this phantom wall's edges
    return wallEdges(w).some(e => edgeKey(e.a, e.b) === edgeKey(from, to));
  });
  if (crossedPhantoms.length) {
    crossedPhantoms.forEach(w => {
      addLog(pi, 'system', `Walked through a phantom wall — it dissolves!`);
      gameState.players[w.owner] = {
        ...gameState.players[w.owner],
        wallsInPlay: Math.max(0, gameState.players[w.owner].wallsInPlay - 1)
      };
    });
    gameState.walls = gameState.walls.filter(w => !crossedPhantoms.includes(w));
  }

  // Phantoms only dissolve when a player physically crosses through them (see above).
  // Stepping adjacent does NOT reveal or remove them.

  const goalRow = pi===0 ? 0 : BOARD_SIZE-1;
  if (to.row === goalRow) {
    gameState.winner = pi;
    gameState.phase = 'ended';
    addLog(pi, 'system', `PLAYER ${pi} WINS — reached the goal!`);
    renderAll();
    showVictory(pi);
    return;
  }

  if (isTurnDone()) {
    gameState.phase = 'end_turn';
    renderAll();
    showStatus('Moved — end your turn', 'success');
  } else {
    // Magnus passive: may play a 2nd Wall card after moving
    const champId = gameState.players[pi].champion.id;
    const msg = champId === 'magnus' ? 'Moved — now play another card or end your turn' : (champId === 'soren' && !gameState._sorenSecondMove ? 'Moved — move again or play a card, or end your turn' : 'Moved — you may still play a card or end your turn');
    renderAll();
    showStatus(msg, 'active');
  }
}

function executePlaceWall(anchor, orientation, length, isPhantom=false, isDurable=false, fromCardId='') {
  const pi = gameState.activePlayer;
  const p = gameState.players[pi];
  // Redirect: wall belongs to opponent but placed by current player
  const ownerOverride = selectedCard?._redirectOwner;
  const wallOwner = (ownerOverride !== undefined) ? ownerOverride : pi;
  // AR1 Reinforced Slab places a pre-reinforced wall
  const cardDef = CARDS[fromCardId];
  const isReinforced = !!(cardDef?.reinforced);
  const isBinding    = !!(cardDef?.binding);
  const isNoJump     = !!(cardDef?.noJump);
  const wall = {
    id: `w${gameState.nextWallId++}`,
    owner: wallOwner,
    anchor, orientation, length,
    isPhantom, durable: isDurable,
    durableHits: 0, immune: isReinforced, reinforced: isReinforced,
    permanent: isReinforced,
    binding: isBinding,
    noJump: isNoJump,
    temporary: false, turnsRemaining: null,
    placedOnTurn: gameState.turnNumber,
  };
  gameState.walls = [...gameState.walls, wall];
  // Phantoms count toward wall limit — they use a slot on the board
  // For redirects (_redirectOwner set), the wall was already counted — don't increment
  const isRedirectPlace = (selectedCard?._redirectOwner !== undefined);
  if (!isRedirectPlace) {
    gameState.players[wallOwner] = {...gameState.players[wallOwner],
      wallsInPlay: gameState.players[wallOwner].wallsInPlay + 1};
  }
  addLog(pi, 'wall', `Placed ${isPhantom?'Phantom ':''}${isReinforced?'Reinforced ':''}wall at (${anchor.row},${anchor.col}) ${orientation}${length}`);
  uiMode = 'idle';
  selectedCard = null;
  onWallPlaced(pi, fromCardId);
}

function discardCard(pi, idx) {
  const p = gameState.players[pi];
  if (idx < 0 || idx >= p.hand.length) return null; // guard invalid index
  const card = p.hand[idx];
  if (!card) return null;
  gameState.players[pi] = {
    ...p,
    hand: p.hand.filter((_,i) => i!==idx),
    discard: [...p.discard, card],
  };
  return card;
}

function endTurnHuman() {
  // Player cannot end turn while AI is thinking or it's the AI's turn
  if (aiThinking || gameState.activePlayer === AI_PLAYER) {
    showStatus("It's the AI's turn", 'error'); return;
  }
  // If a movement card is pending (selected but not yet used), discard it now
  if (selectedCard && selectedCard._pendingMove && selectedCard.idx >= 0) {
    const pi = gameState.activePlayer;
    discardCard(pi, selectedCard.idx);
    countCardPlayed(pi);
    selectedCard = null;
    uiMode = 'idle';
  }
  endTurn();
}

function endTurn() {
  if (gameState.phase === 'ended') return;
  if (gameState.phase === 'draw') { showStatus('Draw your hand first', 'error'); return; }
  if (aiThinking) return;

  const pi = gameState.activePlayer;
  const p = gameState.players[pi];

  // Charge ultimate
  const newCharge = Math.min(p.ultimateCharge+1, p.champion.ultimateCost);
  const ready = newCharge >= p.champion.ultimateCost && !p.ultimateUsed;

  // Tick status effects — when skip_move expires, grant 1-turn bind_cooldown so player can escape
  const hadSkip = p.statusEffects.some(e => e.type === 'skip_move' && e.turnsRemaining === 1);
  let effects = p.statusEffects
    .map(e => ({...e, turnsRemaining: e.turnsRemaining-1}))
    .filter(e => e.turnsRemaining > 0);
  if (hadSkip && !effects.some(e => e.type === 'bind_cooldown')) {
    effects = [...effects, { type:'bind_cooldown', turnsRemaining:1 }];
  }

  gameState.players[pi] = {...p, ultimateCharge: newCharge, ultimateReady: ready, statusEffects: effects};

  // Tick temporary walls
  gameState.walls = gameState.walls.filter(w => !w.temporary || w.turnsRemaining > 1)
    .map(w => w.temporary ? {...w, turnsRemaining: w.turnsRemaining-1} : w);

  onEndTurnPassives(pi);
  const next = pi===0?1:0;
  gameState.activePlayer = next;
  if (pi===1) gameState.turnNumber++;
  gameState.phase = 'draw';
  uiMode = 'idle';
  selectedCard = null;
  resetTurnState();

  addLog(next, 'system', `Turn ${gameState.turnNumber} — Player ${next=== AI_PLAYER?'AI':'0'}`);
  renderAll();
  performDraw();
}

function addLog(player, type, message) {
  gameState.log.push({turn: gameState.turnNumber, player, type, message});
}

// ── AI ────────────────────────────────────────────────────────────────
//
// Core idea: every action changes two distances —
//   myDist  = BFS steps for AI  to reach row BOARD_SIZE-1
//   oppDist = BFS steps for opp to reach row 0
//
// Score of any action = (oppDistAfter - oppDistBefore) * W_OPP
//                     - (myDistAfter  - myDistBefore)  * W_ME
//
// A move that shortens myDist by 1 scores +W_ME.
// A wall that lengthens oppDist by 2 scores +2*W_OPP.
// The AI picks whichever action has the highest score.
//
// Difficulty adjusts weights and wall search depth:
//   easy:   mostly ignores walls (low W_OPP, narrow candidate set)
//   medium: balanced
//   hard:   fully evaluates every candidate wall, prioritises blocking

// Difficulty base weights
const AI_WEIGHTS = {
  easy:   { me: 10, opp: 4,  wallCands: 12 },
  medium: { me: 8,  opp: 10, wallCands: 24 },
  hard:   { me: 6,  opp: 16, wallCands: 64 },
};

// Faction strategy modifiers — how each faction weights move vs wall actions
// moveBonus:  added to score of any move action
// wallBonus:  added to score of any wall action
// aggression: multiplier on "my distance gain" (higher = rushes more)
// control:    multiplier on "opponent distance loss" (higher = walls more)
function getAIFaction() {
  return gameState?.players[AI_PLAYER]?.champion?.faction || 'Architects';
}

// bfsDistanceFor: BFS from a position accounting for phantom walls from the mover's perspective
function bfsDistanceFor(from, goalRow, walls, moverPi) {
  const blocked = buildBlockedEdges(walls, moverPi);
  const visited = new Set();
  const queue = [[from, 0]];
  visited.add(`${from.row},${from.col}`);
  const dirs = [{r:-1,c:0},{r:1,c:0},{r:0,c:1},{r:0,c:-1}];
  while (queue.length) {
    const [cur, dist] = queue.shift();
    if (cur.row === goalRow) return dist;
    for (const d of dirs) {
      const nb = {row:cur.row+d.r, col:cur.col+d.c};
      if (nb.row<0||nb.row>=BOARD_SIZE||nb.col<0||nb.col>=BOARD_SIZE) continue;
      const k = `${nb.row},${nb.col}`;
      if (visited.has(k)) continue;
      if (isEdgeBlocked(cur, nb, blocked)) continue;
      visited.add(k);
      queue.push([nb, dist+1]);
    }
  }
  return Infinity;
}

function scoreAction(action, walls, aiPos, oppPos) {
  // AI is always player 1, opponent is player 0
  const myDistBefore  = bfsDistanceAI(aiPos,  BOARD_SIZE - 1, walls);
  const oppDistBefore = bfsDistanceFor(oppPos, 0,              walls, 0);

  let newWalls = walls, newAiPos = aiPos;

  if (action.type === 'move') {
    newAiPos = action.to;
  } else if (action.type === 'wall' || action.type === 'phantom') {
    const w = {
      id: '__sim__', owner: AI_PLAYER,
      anchor: action.anchor, orientation: action.orientation, length: action.length,
      isPhantom: action.type === 'phantom',
      durable: false, durableHits: 0,
      immune: false, temporary: false, turnsRemaining: null, placedOnTurn: 0,
    };
    newWalls = [...walls, w];
  } else if (action.type === 'removeWall') {
    // Disruption: remove a wall from the board
    newWalls = walls.filter(w => w.id !== action.wallId);
  } else if (action.type === 'shrinkWall') {
    newWalls = walls.map(w => w.id === action.wallId ? {...w, length: Math.max(1, w.length - 1)} : w);
  }

  const myDistAfter  = bfsDistanceAI(newAiPos, BOARD_SIZE - 1, newWalls);
  const oppDistAfter = bfsDistanceFor(oppPos,   0,              newWalls, 0);

  if (myDistAfter  === Infinity) return -1e9;
  if (oppDistAfter === Infinity) return  1e9; // trapping opponent is a win

  const W = AI_WEIGHTS[aiDifficulty];
  const F = FACTION_AI[getAIFaction()] || FACTION_AI['Architects'];

  const myGain  = (myDistBefore  - myDistAfter)  * F.aggression;
  const oppLoss = (oppDistAfter  - oppDistBefore) * F.control;
  const base    = myGain * W.me + oppLoss * W.opp;

  if (action.type === 'move')    return base + F.moveBonus;
  if (action.type === 'wall')    return base + F.wallBonus;
  if (action.type === 'phantom') return base + F.wallBonus * 0.8; // slightly less certain
  return base; // disruption actions scored purely on distance delta
}

// Generate wall placement candidates.
// For hard mode we sweep the full board; lower difficulties use a focused set.
function generateWallCandidates(oppPos, length) {
  const W = AI_WEIGHTS[aiDifficulty];
  const maxCands = W.wallCands;
  const candidates = [];

  if (aiDifficulty === 'hard') {
    // Full board sweep — every legal anchor position
    for (let r = 0; r <= BOARD_SIZE - 2; r++) {
      for (let c = 0; c <= BOARD_SIZE - length; c++) {
        candidates.push({ anchor: { row: r, col: c }, orientation: 'H' });
      }
    }
    for (let r = 0; r <= BOARD_SIZE - length; r++) {
      for (let c = 0; c <= BOARD_SIZE - 2; c++) {
        candidates.push({ anchor: { row: r, col: c }, orientation: 'V' });
      }
    }
  } else {
    // Medium/easy: focused around opponent position
    const col = oppPos.col;
    for (let r = 0; r < oppPos.row; r++) {
      for (let startC = Math.max(0, col - length); startC <= Math.min(BOARD_SIZE - length, col + 1); startC++) {
        candidates.push({ anchor: { row: r, col: startC }, orientation: 'H' });
      }
    }
    for (let r = Math.max(0, oppPos.row - 3); r < Math.min(BOARD_SIZE - length, oppPos.row + 2); r++) {
      if (col > 0)              candidates.push({ anchor: { row: r, col: col - 1 }, orientation: 'V' });
      if (col < BOARD_SIZE - 2) candidates.push({ anchor: { row: r, col: col },     orientation: 'V' });
    }
    // Also include cells between AI and goal (midfield blocking)
    const aiPos = gameState.players[AI_PLAYER].position;
    const midRow = Math.floor((aiPos.row + BOARD_SIZE - 1) / 2);
    for (let r = midRow - 1; r <= midRow + 1; r++) {
      if (r < 0 || r >= BOARD_SIZE - 1) continue;
      for (let startC = 0; startC <= BOARD_SIZE - length; startC++) {
        candidates.push({ anchor: { row: r, col: startC }, orientation: 'H' });
      }
    }
  }

  // Shuffle then trim to budget so hard mode doesn't freeze the browser
  return shuffle(candidates).slice(0, maxCands);
}

// ── Phantom wall probability model ────────────────────────────────────
// Tracks which opponent walls the AI has "probed" (been adjacent to and
// survived — meaning they are confirmed real walls).
const aiProbedWallIds = new Set();

// Returns 0.0–1.0: probability that a given opponent wall is a phantom.
// Used by the AI to discount path blockage of uncertain walls.
function phantomProbability(wall) {
  if (!wall || wall.owner !== 0) return 0;           // AI's own wall or unknown
  if (wall.isPhantom) return 0;                      // AI can see its own phantoms in gameState (owner===1)
  // If opponent is not a Phantoms faction, they have no phantom cards
  const oppFaction = gameState.players[0].champion.faction;
  if (oppFaction !== 'Phantoms') return 0;
  // If we've been adjacent and wall survived, it's confirmed real
  if (aiProbedWallIds.has(wall.id)) return 0;
  // Otherwise: all Trickster walls are suspect — 50% phantom probability
  return 0.5;
}

// Compute AI's BFS distance treating suspect walls as partially transparent.
// uncertainty = 0: treat all walls as real (pessimistic)
// uncertainty = 1: ignore all suspect walls (optimistic)
// We blend: effectiveDist = pessimistic * (1-p) + optimistic * p
function bfsDistanceAI(from, goalRow, walls) {
  const oppFaction = gameState.players[0].champion.faction;
  if (oppFaction !== 'Phantoms') {
    return bfsDistanceFor(from, goalRow, walls, AI_PLAYER);
  }

  // Pessimistic: all walls real (standard)
  const pessimistic = bfsDistanceFor(from, goalRow, walls, AI_PLAYER);

  // Optimistic: remove all 50%-suspect opponent walls
  const suspectIds = new Set(
    walls.filter(w => phantomProbability(w) > 0).map(w => w.id)
  );
  if (!suspectIds.size) return pessimistic;

  const optimisticWalls = walls.filter(w => !suspectIds.has(w.id));
  const optimistic = bfsDistanceFor(from, goalRow, optimisticWalls, AI_PLAYER);

  // Blend at 50/50 probability
  if (pessimistic === Infinity && optimistic === Infinity) return Infinity;
  if (pessimistic === Infinity) return optimistic;  // suspect walls are entirely blocking: likely phantoms
  return pessimistic * 0.5 + optimistic * 0.5;
}

// Score bonus for moves that probe suspect phantom walls.
// A probe is valuable if: getting adjacent to a suspect wall would reveal it,
// AND revealing it would meaningfully shorten the AI's path.
function probeBonus(moveDest, walls) {
  const oppFaction = gameState.players[0].champion.faction;
  if (oppFaction !== 'Phantoms') return 0;

  const dirs = [{r:-1,c:0},{r:1,c:0},{r:0,c:1},{r:0,c:-1}];
  let bonus = 0;

  for (const w of walls) {
    if (phantomProbability(w) === 0) continue;
    // Would moving to moveDest put us adjacent to this wall?
    const isAdjacent = wallEdges(w).some(e =>
      (e.a.row === moveDest.row && e.a.col === moveDest.col) ||
      (e.b.row === moveDest.row && e.b.col === moveDest.col)
    );
    if (!isAdjacent) continue;

    // How much would revealing (removing) this wall help the AI?
    const withWall    = bfsDistanceFor(moveDest, BOARD_SIZE - 1, walls, AI_PLAYER);
    const withoutWall = bfsDistanceFor(moveDest, BOARD_SIZE - 1,
                          walls.filter(x => x.id !== w.id), AI_PLAYER);
    const gain = withWall - withoutWall;
    if (gain > 0) {
      // Bonus scaled by probability and gain, discounted slightly (might be real)
      bonus += gain * phantomProbability(w) * 1.5;
    }
  }
  return bonus;
}

// Called after AI successfully stays adjacent to a wall without it disappearing
// (i.e. the wall survived a turn being next to it) — mark as confirmed real
function markProbedWalls() {
  if (!gameState) return;
  const aiPos = gameState.players[AI_PLAYER]?.position;
  if (!aiPos) return;
  const dirs = [{r:-1,c:0},{r:1,c:0},{r:0,c:1},{r:0,c:-1}];
  for (const w of gameState.walls) {
    if (phantomProbability(w) === 0) continue;
    const adj = wallEdges(w).some(e =>
      (e.a.row === aiPos.row && e.a.col === aiPos.col) ||
      (e.b.row === aiPos.row && e.b.col === aiPos.col)
    );
    if (adj) aiProbedWallIds.add(w.id);
  }
}

function runAI() {
  if (gameState.phase !== 'action' || gameState.activePlayer !== AI_PLAYER) {
    aiThinking = false; return;
  }

  maybeAIUltimate(AI_PLAYER);

  // Mark any walls the AI was adjacent to at start of turn (they survived = real)
  markProbedWalls();

  const pi        = AI_PLAYER;
  const aiFaction = gameState.players[pi].champion.faction;

  // ── Helper: snapshot current state for simulation ─────────────────
  function snap() {
    return {
      aiPos:   gameState.players[pi].position,
      oppPos:  gameState.players[0].position,
      walls:   gameState.walls,
      aiHand:  gameState.players[pi].hand,
      aiWalls: gameState.players[pi].wallsInPlay,
      aiLimit: gameState.players[pi].wallLimitCurrent,
    };
  }

  // ══════════════════════════════════════════════════════════════════
  // PHASE 1 — choose the CARD action (or no card if hand is empty)
  // ══════════════════════════════════════════════════════════════════
  let bestCardScore = -Infinity;
  let bestCardAction = null;  // null = skip card, play base move only

  const st = snap();

  // ── A: Wall cards (real placement) ────────────────────────────────
  if (st.aiWalls < st.aiLimit) {
    const wallCards = st.aiHand.filter(c =>
      c.type === 'Wall' && !c.phantom && !c.special
    );
    for (const card of wallCards) {
      const len = getCardWallLength(card.id);
      const cands = generateWallCandidates(st.oppPos, len);
      for (const {anchor, orientation} of cands) {
        if (!isWallLegal(anchor, orientation, len, st.walls,
            st.oppPos, st.aiPos, false)) continue;
        const s = scoreAction({type:'wall', anchor, orientation, length:len},
                              st.walls, st.aiPos, st.oppPos);
        if (s > bestCardScore) {
          bestCardScore = s;
          bestCardAction = {kind:'wall', card, anchor, orientation, len};
        }
      }
    }
  }

  // ── B: Phantom wall cards (Phantoms faction) ────────────────────────
  if (aiFaction === 'Phantoms' && st.aiWalls < st.aiLimit) {
    const phantomCards = st.aiHand.filter(c => c.type === 'Wall' && c.phantom && !c.special);
    for (const card of phantomCards) {
      const len = 2;
      const cands = generateWallCandidates(st.oppPos, len);
      for (const {anchor, orientation} of cands) {
        // Phantom must not block AI's own real path
        if (!isWallLegal(anchor, orientation, len, st.walls,
            st.oppPos, st.aiPos, true)) continue;
        const s = scoreAction({type:'phantom', anchor, orientation, length:len},
                              st.walls, st.aiPos, st.oppPos);
        if (s > bestCardScore) {
          bestCardScore = s;
          bestCardAction = {kind:'phantom', card, anchor, orientation, len};
        }
      }
    }
  }

  // ── C: Special wall cards (Double Bluff, Corner Piece) ────────────
  if (st.aiWalls < st.aiLimit) {
    const specialCards = st.aiHand.filter(c => c.type === 'Wall' && c.special);
    for (const card of specialCards) {
      // Treat as a standard wall of the base length for scoring
      const len = getCardWallLength(card.id);
      const cands = generateWallCandidates(st.oppPos, len);
      for (const {anchor, orientation} of cands) {
        if (!isWallLegal(anchor, orientation, len, st.walls,
            st.oppPos, st.aiPos, false)) continue;
        const s = scoreAction({type:'wall', anchor, orientation, length:len},
                              st.walls, st.aiPos, st.oppPos) + 1; // slight bonus for special
        if (s > bestCardScore) {
          bestCardScore = s;
          bestCardAction = {kind:'wall', card, anchor, orientation, len};
        }
      }
    }
  }

  // ── E: Movement cards — score best move achievable with card boost ──
  {
    const moveCards = st.aiHand.filter(c => c.type === 'Movement');
    for (const card of moveCards) {
      const speed = card.overrideSpeed || 2;
      const simState = {...gameState, walls: st.walls};
      const boostedMoves = getLegalMoves(simState, pi, speed);
      let bestMoveWithCard = -Infinity;
      let bestDest = null;
      for (const to of boostedMoves) {
        if (to.row === BOARD_SIZE - 1) { bestDest = to; bestMoveWithCard = 1e9; break; }
        const s = scoreAction({type:'move', to}, st.walls, st.aiPos, st.oppPos) + 1;
        if (s > bestMoveWithCard) { bestMoveWithCard = s; bestDest = to; }
      }
      // A movement card is worthwhile if it scores significantly better than base move
      const baseBestDist = bfsDistanceAI(st.aiPos, BOARD_SIZE - 1, st.walls);
      const moveDist = bestDest ? Math.abs(bestDest.row - (BOARD_SIZE - 1)) : baseBestDist;
      if (bestDest && bestMoveWithCard > bestCardScore && bestMoveWithCard > 2) {
        bestCardScore = bestMoveWithCard;
        bestCardAction = {kind:'movement', card, dest: bestDest};
      }
    }
  }

  // ── D: Disruption cards ───────────────────────────────────────────
  const dispCards = st.aiHand.filter(c => c.type === 'Disruption');
  for (const card of dispCards) {

    // RC Reconstruction / A3 Reclaim: removes oldest own wall, draws 1.
    if (card.id === 'A3' || card.id === 'RC') {
      const myWalls = st.walls.filter(w => w.owner===pi && !w.isPhantom && !w.permanent)
                               .sort((a,b) => a.placedOnTurn - b.placedOnTurn);
      if (!myWalls.length) continue;
      const target = myWalls[0];
      const simWalls = st.walls.filter(w => w.id !== target.id);
      const myDistAfter  = bfsDistanceFor(st.aiPos,  BOARD_SIZE-1, simWalls, pi);
      const oppDistAfter = bfsDistanceFor(st.oppPos, 0,            simWalls, 0);
      const myGain  = (bfsDistanceFor(st.aiPos, BOARD_SIZE-1, st.walls, pi) - myDistAfter);
      const oppGain = (bfsDistanceFor(st.oppPos, 0, st.walls, 0) - oppDistAfter);
      const s = myGain * 8 - oppGain * 6 - 1;
      if (s > bestCardScore) {
        bestCardScore = s;
        bestCardAction = {kind:'disruption', subkind:'reclaim', card};
      }
    }

    // AR3 Blueprint Shift / A4 Redeploy: lift own wall, re-place it optimally
    if (card.id === 'A4' || card.id === 'AR3') {
      const myWalls = st.walls.filter(w => w.owner===pi && !w.isPhantom && !w.permanent && !w.reinforced);
      for (const target of myWalls) {
        const wallsWithout = st.walls.filter(w => w.id !== target.id);
        const len = target.length;
        const cands = generateWallCandidates(st.oppPos, len);
        for (const {anchor, orientation} of cands) {
          if (anchor.row===target.anchor.row && anchor.col===target.anchor.col &&
              orientation===target.orientation) continue;
          if (!isWallLegal(anchor, orientation, len, wallsWithout,
              st.oppPos, st.aiPos, false)) continue;
          const simWalls = [...wallsWithout, {
            id:'__sim__', owner:pi, anchor, orientation, length:len,
            isPhantom:false, durable:false, durableHits:0, immune:false, reinforced:false,
            temporary:false, turnsRemaining:null, placedOnTurn:0
          }];
          const s = scoreAction({type:'wall', anchor, orientation, length:len},
                                wallsWithout, st.aiPos, st.oppPos) + 0.5;
          if (s > bestCardScore) {
            bestCardScore = s;
            bestCardAction = {kind:'disruption', subkind:'redeploy', card, target, anchor, orientation, len};
          }
        }
      }
    }

    // AR2 Reinforce Wall: reinforce most valuable own wall
    if (card.id === 'A5' || card.id === 'AR2') {
      const myWalls = gameState.walls.filter(w => w.owner===pi && !w.isPhantom && !w.reinforced);
      if (!myWalls.length) continue;
      const best = myWalls[myWalls.length - 1];
      // Value: how much does this wall contribute to opponent's distance?
      const withoutWall = st.walls.filter(w => w.id !== best.id);
      const oppWithout  = bfsDistanceFor(st.oppPos, 0, withoutWall, 0);
      const oppWith     = bfsDistanceFor(st.oppPos, 0, st.walls,    0);
      const wallValue   = oppWithout - oppWith;
      const s = wallValue * 6 - 1;
      if (s > bestCardScore) {
        bestCardScore = s;
        bestCardAction = {kind:'disruption', subkind:'reinforce', card};
      }
    }

    // T3 Redirect / WD3 Eviction: move opponent's non-reinforced wall
    if (card.id === 'T3' || card.id === 'WD3') {
      const oppWalls = st.walls.filter(w => w.owner===0 && !w.isPhantom && !w.permanent && !w.reinforced && !w.immune);
      for (const target of oppWalls) {
        const wallsWithout = st.walls.filter(w => w.id !== target.id);
        const len = target.length;
        const cands = generateWallCandidates(st.oppPos, len);
        for (const {anchor, orientation} of cands) {
          if (!isWallLegal(anchor, orientation, len, wallsWithout,
              st.oppPos, st.aiPos, false)) continue;
          const s = scoreAction({type:'wall', anchor, orientation, length:len},
                                wallsWithout, st.aiPos, st.oppPos) + 1;
          if (s > bestCardScore) {
            bestCardScore = s;
            bestCardAction = {kind:'disruption', subkind:'redirect', card, target, anchor, orientation, len};
          }
        }
      }
    }

    // T4 Scatter / WD2 Tax Notice: opponent discards a card
    if (card.id === 'T4' || card.id === 'WD2') {
      const oppHandSize = gameState.players[0].hand.length;
      if (oppHandSize > 0) {
        const s = 3;
        if (s > bestCardScore) {
          bestCardScore = s;
          bestCardAction = {kind:'disruption', subkind:'scatter', card};
        }
      }
    }

    // T5 Punch Through: shrink/remove most-blocking wall (not reinforced)
    if (card.id === 'T5') {
      const breakable = st.walls.filter(w => !w.isPhantom && !w.permanent && !w.reinforced && !w.immune);
      for (const target of breakable) {
        const action = target.length <= 1
          ? {type:'removeWall', wallId:target.id}
          : {type:'shrinkWall', wallId:target.id};
        const s = scoreAction(action, st.walls, st.aiPos, st.oppPos) + 0.5;
        if (s > bestCardScore) {
          bestCardScore = s;
          bestCardAction = {kind:'disruption', subkind:'punchthrough', card, target};
        }
      }
    }

    // S5 Seal: permanently protect the AI's best blocking wall
    if (card.id === 'S5') {
      const myWalls = st.walls.filter(w => w.owner===pi && !w.isPhantom && !w.permanent);
      if (!myWalls.length) continue;
      // Pick the wall that blocks opponent most
      let bestWall = null, bestVal = -Infinity;
      for (const w of myWalls) {
        const without = st.walls.filter(x => x.id !== w.id);
        const val = bfsDistanceFor(st.oppPos, 0, without, 0) - bfsDistanceFor(st.oppPos, 0, st.walls, 0);
        if (val > bestVal) { bestVal = val; bestWall = w; }
      }
      if (bestWall && bestVal > 1) {
        const s = bestVal * 5;
        if (s > bestCardScore) {
          bestCardScore = s;
          bestCardAction = {kind:'disruption', subkind:'seal', card, target:bestWall};
        }
      }
    }
  }

  // ══════════════════════════════════════════════════════════════════
  // PHASE 2 — choose the MOVE action
  // ══════════════════════════════════════════════════════════════════
  // Simulate post-card wall state, then find best move
  let simWallsForMove = st.walls;
  if (bestCardAction && (bestCardAction.kind === 'wall' || bestCardAction.kind === 'phantom')) {
    simWallsForMove = [...st.walls, {
      id:'__premove__', owner:pi,
      anchor:bestCardAction.anchor, orientation:bestCardAction.orientation, length:bestCardAction.len,
      isPhantom: bestCardAction.kind === 'phantom',
      durable:false, durableHits:0, immune:false, temporary:false, turnsRemaining:null, placedOnTurn:0
    }];
  }

  const simState = {
    ...gameState,
    walls: simWallsForMove
  };
  const moves = getLegalMoves(simState, pi);

  let bestMoveScore = -Infinity;
  let bestMoveDest  = null;

  for (const to of moves) {
    if (to.row === BOARD_SIZE - 1) { bestMoveDest = to; bestMoveScore = 1e9; break; }
    const s = scoreAction({type:'move', to}, simWallsForMove, st.aiPos, st.oppPos)
            + probeBonus(to, simWallsForMove);
    if (s > bestMoveScore) { bestMoveScore = s; bestMoveDest = to; }
  }

  // Fallback move if none scored positively
  if (!bestMoveDest && moves.length) {
    bestMoveDest = moves.reduce((a, b) =>
      Math.abs(b.row - (BOARD_SIZE - 1)) < Math.abs(a.row - (BOARD_SIZE - 1)) ? b : a
    );
  }

  // ══════════════════════════════════════════════════════════════════
  // PHASE 3 — execute card action (if any)
  // ══════════════════════════════════════════════════════════════════
  if (bestCardAction) {
    const {kind, card} = bestCardAction;
    const cardIdx = gameState.players[pi].hand.findIndex(c => c.id === card.id);
    if (cardIdx === -1) {
      // Card no longer in hand — skip
    } else if (kind === 'movement') {
      // Execute movement card: discard it and use the boosted move destination
      discardCard(pi, cardIdx);
      countCardPlayed(pi);
      addLog(pi, 'card', 'AI played: ' + card.name);
      // Override best move with the card's boost
      if (bestCardAction.dest) {
        bestMoveDest = bestCardAction.dest;
      }
    } else if (kind === 'wall' || kind === 'phantom') {
      discardCard(pi, cardIdx);
      executePlaceWall(bestCardAction.anchor, bestCardAction.orientation,
                       bestCardAction.len, kind === 'phantom', false, card.id);
    } else if (kind === 'disruption') {
      const sub = bestCardAction.subkind;

      if (sub === 'reclaim') {
        // Execute RC Reconstruction / A3: remove oldest wall, draw 1
        const myWalls = gameState.walls.filter(w => w.owner===pi && !w.isPhantom && !w.permanent)
                                       .sort((a,b) => a.placedOnTurn - b.placedOnTurn);
        if (myWalls.length) {
          const target = myWalls[0];
          gameState.walls = gameState.walls.filter(w => w.id !== target.id);
          gameState.players[pi] = {...gameState.players[pi],
            wallsInPlay: Math.max(0, gameState.players[pi].wallsInPlay - 1)};
          discardCard(pi, cardIdx);
          drawCards(pi, 1);
          countCardPlayed(pi);
          addLog(pi, 'card', 'AI Reconstruction: recycled oldest wall, drew 1');
        }

      } else if (sub === 'redeploy') {
        // Execute AR3 Blueprint Shift / A4 Redeploy: lift target wall, place at new location
        const t = bestCardAction.target;
        if (gameState.walls.find(w => w.id === t.id)) {
          gameState.walls = gameState.walls.filter(w => w.id !== t.id);
          gameState.players[pi] = {...gameState.players[pi],
            wallsInPlay: Math.max(0, gameState.players[pi].wallsInPlay - 1)};
          discardCard(pi, cardIdx);
          executePlaceWall(bestCardAction.anchor, bestCardAction.orientation,
                           bestCardAction.len, false, t.durable||false, card.id);
          addLog(pi, 'card', 'AI Blueprint Shift: repositioned wall');
        }

      } else if (sub === 'reinforce') {
        const myWalls = gameState.walls.filter(w => w.owner===pi && !w.isPhantom && !w.reinforced);
        if (myWalls.length) {
          // Pick most valuable wall
          let bestWall = myWalls[myWalls.length-1];
          let bestVal = -1;
          for (const w of myWalls) {
            const wo = gameState.walls.filter(x => x.id !== w.id);
            const val = bfsDistanceFor(gameState.players[0].position, 0, wo, 0) - bfsDistanceFor(gameState.players[0].position, 0, gameState.walls, 0);
            if (val > bestVal) { bestVal = val; bestWall = w; }
          }
          gameState.walls = gameState.walls.map(w =>
            w.id === bestWall.id ? {...w, reinforced:true, immune:true, permanent:true} : w
          );
          discardCard(pi, cardIdx); countCardPlayed(pi);
          addLog(pi, 'card', 'AI Reinforce: wall permanently reinforced');
        }

      } else if (sub === 'redirect') {
        const t = bestCardAction.target;
        if (gameState.walls.find(w => w.id === t.id)) {
          // Remove from opponent (but don't decrement wallsInPlay — wall ownership stays with opponent)
          gameState.walls = gameState.walls.filter(w => w.id !== t.id);
          discardCard(pi, cardIdx);
          // Place as opponent's wall at new position
          selectedCard = {id: card.id, idx:-1, length:bestCardAction.len,
                          isPhantom:false, isDurable:false, _redirectOwner:0};
          executePlaceWall(bestCardAction.anchor, bestCardAction.orientation,
                           bestCardAction.len, false, false, card.id);
          selectedCard = null;
          addLog(pi, 'card', 'AI ' + card.name + ': relocated opponent wall');
        }

      } else if (sub === 'scatter') {
        // T4 Scatter / WD2 Tax Notice
        const op = gameState.players[0];
        if (op.hand.length) {
          const ridx = Math.floor(Math.random() * op.hand.length);
          const gone = op.hand[ridx];
          gameState.players[0] = {...op,
            hand: op.hand.filter((_,i)=>i!==ridx),
            discard:[...op.discard, gone]};
          addLog(pi, 'card', 'AI: discarded opponent card ' + gone.name);
        }
        discardCard(pi, cardIdx); countCardPlayed(pi);

      } else if (sub === 'punchthrough') {
        const t = bestCardAction.target;
        const live = gameState.walls.find(w => w.id === t.id);
        if (live && !live.reinforced && !live.immune) {
          if (live.length <= 1) {
            gameState.walls = gameState.walls.filter(w => w.id !== live.id);
            if (!live.isPhantom)
              gameState.players[live.owner] = {...gameState.players[live.owner],
                wallsInPlay: Math.max(0, gameState.players[live.owner].wallsInPlay - 1)};
          } else {
            gameState.walls = gameState.walls.map(w => w.id===live.id ? {...w, length:w.length-1} : w);
          }
          addLog(pi, 'card', 'AI Punch Through: wall damaged');
        }
        discardCard(pi, cardIdx); countCardPlayed(pi);

      } else if (sub === 'seal') {
        const t = bestCardAction.target;
        if (gameState.walls.find(w => w.id === t.id)) {
          gameState.walls = gameState.walls.map(w =>
            w.id === t.id ? {...w, permanent:true, immune:true} : w
          );
          addLog(pi, 'card', 'AI Seal: wall permanently sealed');
        }
        discardCard(pi, cardIdx); countCardPlayed(pi);
      }
    }
  }

  // ══════════════════════════════════════════════════════════════════
  // PHASE 4 — execute move (skip if Binding Wall effect active)
  // ══════════════════════════════════════════════════════════════════
  const isAIBound = (gameState.players[AI_PLAYER].statusEffects || []).some(e => e.type === 'skip_move' && e.turnsRemaining > 0);
  if (bestMoveDest && !hasMoved && !isAIBound) {
    executeMove(bestMoveDest);
  } else if (isAIBound) {
    hasMoved = true; // mark as "moved" so isTurnDone works correctly
    addLog(AI_PLAYER, 'system', 'AI bound by Binding Wall — move skipped');
  }

  // ── If turn still not done, force-end (safety net) ─────────────────
  if (gameState.phase === 'action' && gameState.activePlayer === AI_PLAYER) {
    gameState.phase = 'end_turn';
  }
  aiThinking = false;
  renderAll();

  if (gameState.phase === 'end_turn' && gameState.activePlayer === AI_PLAYER) {
    setTimeout(endTurn, 700);
  }
}

// Stub out old functions so no references break
function wallCandidatesForMinimax() { return []; }
function enumerateActions()         { return []; }
function applyActionToSnapshot()    { return {}; }
function minimax()                  { return 0;  }
function evalScore()                { return 0;  }


// ── Champion Select ──────────────────────────────────────────────────

function showChampionSelect() {
  selectedChampionId = null;

  const factionColors = {
    Architects:  'var(--wall-arch)',
    Pathfinders: 'var(--wall-path)',
    Wardens:     'var(--wall-ward)',
    Phantoms:    'var(--wall-phan)',
    Adepts:      'var(--wall-adept)',
  };

  const cards = Object.values(CHAMPIONS).map(champ => {
    const col = factionColors[champ.faction] || 'var(--text-dim)';
    return `<div class="cs-card" id="cs-${champ.id}" onclick="selectChampion('${champ.id}')">
      <div class="cs-champ-name" style="color:${col}">${champ.name}</div>
      <div class="cs-champ-title">${champ.title}</div>
      <div class="cs-faction" style="color:${col}">${champ.faction}</div>
      <div class="cs-stats">
        <div class="cs-stat"><div class="cs-stat-label">WALLS</div><div class="cs-stat-val">${champ.wallLimit}</div></div>
        <div class="cs-stat"><div class="cs-stat-label">HAND</div><div class="cs-stat-val">${champ.handSize}</div></div>
        <div class="cs-stat"><div class="cs-stat-label">OPEN DRAW</div><div class="cs-stat-val">${champ.cardDraw}</div></div>
        <div class="cs-stat"><div class="cs-stat-label">SPEED</div><div class="cs-stat-val">${champ.moveSpeed}</div></div>
      </div>
      <div class="cs-passive">
        <div class="cs-passive-name">${champ.passiveName}</div>
        <div class="cs-passive-desc">${champ.passiveDesc}</div>
      </div>
      <div class="cs-ult-name">&#9889; ${champ.ultimateName}</div>
      <div class="cs-ult-desc">${champ.ultimateDesc || ''}</div>
    </div>`;
  }).join('');

  document.body.insertAdjacentHTML('beforeend', `
    <div id="champion-select-overlay" style="
      position:fixed;inset:0;background:var(--bg);z-index:500;
      display:flex;flex-direction:column;align-items:center;
      justify-content:flex-start;padding:40px 24px;overflow-y:auto;
    ">
      <div style="font-family:'Teko',sans-serif;font-size:42px;font-weight:700;letter-spacing:.3em;color:var(--amber);margin-bottom:4px;">CORRIDORS</div>
      <div style="font-size:11px;letter-spacing:.2em;color:var(--text-dim);text-transform:uppercase;margin-bottom:32px;">Select your champion</div>
      <div style="display:grid;grid-template-columns:repeat(3,280px);gap:16px;margin-bottom:32px;" id="cs-grid">${cards}</div>
      <div style="font-size:10px;letter-spacing:.15em;color:var(--text-dim);margin-bottom:12px;text-transform:uppercase;">AI DIFFICULTY</div>
      <div style="display:flex;gap:8px;margin-bottom:32px;">
        <button class="diff-btn" id="diff-easy"   onclick="setDifficulty('easy')">EASY</button>
        <button class="diff-btn active" id="diff-medium" onclick="setDifficulty('medium')">MEDIUM</button>
        <button class="diff-btn" id="diff-hard"   onclick="setDifficulty('hard')">HARD</button>
      </div>
      <button id="cs-confirm" onclick="confirmChampionSelect()" disabled style="
        padding:14px 48px;background:transparent;border:1px solid var(--amber);
        color:var(--amber);font-family:'JetBrains Mono',monospace;font-size:13px;
        letter-spacing:.2em;text-transform:uppercase;cursor:pointer;opacity:0.4;
      ">SELECT CHAMPION TO CONTINUE &#8594;</button>
    </div>
  `);
}

function selectChampion(id) {
  selectedChampionId = id;
  document.querySelectorAll('.cs-card').forEach(el => el.classList.remove('selected'));
  const card = document.getElementById('cs-' + id);
  if (card) card.classList.add('selected');
  const btn = document.getElementById('cs-confirm');
  if (btn) {
    btn.textContent = 'PLAY AS ' + CHAMPIONS[id].name.toUpperCase() + ' →';
    btn.disabled = false;
    btn.style.opacity = '1';
  }
}

function setDifficulty(level) {
  aiDifficulty = level;
  ['easy', 'medium', 'hard'].forEach(l => {
    const el = document.getElementById('diff-' + l);
    if (el) el.className = 'diff-btn' + (l === level ? ' active' : '');
  });
}

function confirmChampionSelect() {
  if (!selectedChampionId) return;
  const playerFaction  = CHAMPIONS[selectedChampionId].faction;
  const counterFaction = FACTION_COUNTER[playerFaction];
  let aiChampId;

  if (aiDifficulty === 'hard' && counterFaction) {
    // Hard: pick a random champion from the counter faction
    const counterChamps = Object.keys(CHAMPIONS).filter(id =>
      CHAMPIONS[id].faction === counterFaction && id !== selectedChampionId
    );
    aiChampId = counterChamps.length
      ? counterChamps[Math.floor(Math.random() * counterChamps.length)]
      : Object.keys(CHAMPIONS).filter(id => id !== selectedChampionId)[0];
    // Show the counter pick to the player
    setTimeout(() => showStatus('HARD: AI countered with a ' + counterFaction + ' champion!', 'error'), 800);
  } else {
    const available = Object.keys(CHAMPIONS).filter(id => id !== selectedChampionId);
    aiChampId = available[Math.floor(Math.random() * available.length)];
  }

  const overlay = document.getElementById('champion-select-overlay');
  if (overlay) overlay.remove();
  initGame(selectedChampionId, aiChampId);
}

// ── UI interactions ─────────────────────────────────────────────────
function enterMoveMode() {
  if (gameState.activePlayer === AI_PLAYER) return;
  if (gameState.phase !== 'action') { showStatus('Not your action phase', 'error'); return; }
  const pi = gameState.activePlayer;
  const champId = gameState.players[pi].champion.id;
  // Check for Binding Wall skip effect
  const isBound = (gameState.players[pi].statusEffects || []).some(e => e.type === 'skip_move' && e.turnsRemaining > 0);
  if (isBound) {
    showStatus('Bound! A Binding Wall prevents your move this turn', 'error'); return;
  }
  // Soren (Fleetfoot): can take a 2nd move INSTEAD of playing a card (if no card played yet)
  const sorenSecondMovePending = hasMoved && champId === 'soren' && cardsPlayedThisTurn === 0 && !gameState._sorenSecondMove;
  if (sorenSecondMovePending) {
    // Grant Soren a second move
    gameState._sorenSecondMove = true;
    hasMoved = false; // temporarily allow move UI
  } else if (hasMoved) {
    showStatus('Already moved this turn', 'error'); return;
  }

  if (uiMode === 'move') {
    // Toggle off — if we just granted Soren second move, revert it
    if (sorenSecondMovePending) {
      gameState._sorenSecondMove = false;
      hasMoved = true;
    }
    uiMode = 'idle';
    selectedCard = null;
    renderBoard();
    showStatus('Move cancelled', '');
  } else {
    uiMode = 'move';
    selectedCard = null;
    renderBoard();
    showStatus('Click a highlighted tile to move', 'active');
  }
  updateActionBar();
}

function setOrientation(o) {
  wallOrientation = o;
  document.getElementById('orient-h').className = `orient-btn${o==='H'?' active':''}`;
  document.getElementById('orient-v').className = `orient-btn${o==='V'?' active':''}`;
  // Re-render wall hotspots
  if (uiMode === 'wall') renderBoard();
}

function showOrientationToggle() {
  const el = document.getElementById('orientation-toggle');
  if (el) el.style.display = 'flex';
}
function hideOrientationToggle() {
  const el = document.getElementById('orientation-toggle');
  if (el) el.style.display = 'none';
}

function handleCellClick(r, c) {
  if (uiMode !== 'move') return;
  executeMove({row:r, col:c});
  updateActionBar();
}

function handleWallClick(anchor, orientation, length, isPhantom, isDurable) {
  if (uiMode !== 'wall') return;
  const pi = gameState.activePlayer;
  const p = gameState.players[pi];

  // Redirect: the wall being placed belongs to the opponent — check their limit
  const wallOwnerPi = (selectedCard?._redirectOwner !== undefined) ? selectedCard._redirectOwner : pi;
  const wallOwnerState = gameState.players[wallOwnerPi];
  const isRedirectPlace = (selectedCard?._redirectOwner !== undefined);
  // Skip limit check for redirected walls (wall was already counted, just moving it)
  if (!isRedirectPlace && wallOwnerState.wallsInPlay >= wallOwnerState.wallLimitCurrent) {
    const who = wallOwnerPi === pi ? 'Your' : "Opponent's";
    showStatus(`${who} wall limit reached!`, 'error'); return;
  }
  if (!isWallLegal(anchor, orientation, length, gameState.walls,
      gameState.players[0].position, gameState.players[1].position, isPhantom)) {
    showStatus('Illegal — would block a path', 'error'); return;
  }

  // Discard the card that triggered wall mode
  // idx === -1 means this is a chained placement (T2 phantom, G4 second wall, etc.)
  // — the original card was already discarded; don't try to discard again
  const fromCardId = selectedCard ? selectedCard.id : '';
  if (selectedCard && selectedCard.idx >= 0) discardCard(pi, selectedCard.idx);
  executePlaceWall(anchor, orientation, length, isPhantom, isDurable, fromCardId);

  renderAll();
  const _wpi = gameState.activePlayer;
  const _wchamp = gameState.players[_wpi].champion.id;
  if (_wchamp === 'magnus') {
    showStatus('Wall placed — now move or play another card, or end your turn', 'active');
  } else {
    showStatus('Wall placed — end your turn', 'success');
  }
  updateActionBar();

  // If it's AI's turn after this (shouldn't happen, but safety)
  if (gameState.phase === 'end_turn' && gameState.activePlayer === AI_PLAYER) {
    setTimeout(endTurn, 400);
  }
}

// ── Persistent storage ──────────────────────────────────────────────
async function storageGet(key) {
  if (window.storage) { try { return await window.storage.get(key); } catch(e) {} }
  const v = localStorage.getItem(key);
  return v ? { value: v } : null;
}
async function storageSet(key, value) {
  if (window.storage) { try { await window.storage.set(key, value); return; } catch(e) {} }
  try { localStorage.setItem(key, value); } catch(e) {}
}

// ── Per-turn state ───────────────────────────────────────────────────
let opponentLastPlayedWall = false;
// (freeCardPlay / consecutiveMoveTurns removed with Pathfinders)
let cardsPlayedThisTurn    = 0;

function getFactionRule(pi) {
  const faction = gameState.players[pi].champion.faction;
  return FACTION_RULES[faction];
}

function isTurnDone() {
  const pi = gameState.activePlayer;
  const p  = gameState.players[pi];
  const champId = p.champion.id;

  // Binding Wall: if player is bound (skip_move), they can't move — turn done after 1 card (or immediately)
  const isBound = (p.statusEffects || []).some(e => e.type === 'skip_move' && e.turnsRemaining > 0);
  if (isBound) {
    if (cardsPlayedThisTurn >= 1) return true;  // played their card, done
    if (p.hand.length === 0) return true;        // no cards to play, just end
    return false;
  }

  // Magnus (Master Mason): play 2 cards (any type, incl. wall) OR move + play 1 card
  if (champId === 'magnus') {
    if (cardsPlayedThisTurn >= 2) return true;                           // played 2 cards
    if (hasMoved && cardsPlayedThisTurn >= 1) return true;               // moved + played 1
    if (p.hand.length === 0 && hasMoved) return true;                    // hand empty, moved
    if (p.hand.length === 0 && cardsPlayedThisTurn >= 1) return true;    // hand empty, played 1
    return false;
  }

  // Soren (Fleetfoot): move twice (no card) OR move + play 1 card
  if (champId === 'soren') {
    if (gameState._sorenSecondMove && hasMoved) return true;             // moved twice
    if (hasMoved && cardsPlayedThisTurn >= 1) return true;               // moved + played card
    if (p.hand.length === 0 && hasMoved) return true;                    // hand empty, moved
    return false;
  }

  // All other champions: move + play 1 card (or just move if hand empty)
  if (p.hand.length === 0) return hasMoved;
  return hasMoved && cardsPlayedThisTurn >= 1;
}

function resetTurnState() {
  hasMoved            = false;
  hasPlayedCard       = false;
  cardsPlayedThisTurn = 0;
  if (gameState) {
    gameState._turnCategoryWall = false;
    gameState._turnCategoryMovement = false;
    gameState._turnCategoryDisruption = false;
    gameState._adeptEqDrawn = false;
    gameState._sorenSecondMove = false;
  }
}

// ── Card selection dispatcher ────────────────────────────────────────
function selectCard(cardId, idx) {
  if (gameState.activePlayer === AI_PLAYER) return;
  if (gameState.phase !== 'action') { showStatus('Not your action phase', 'error'); return; }

  const pi     = gameState.activePlayer;
  const rule   = getFactionRule(pi);
  const champId = gameState.players[pi].champion.id;
  const card   = gameState.players[pi].hand[idx];
  if (!card) return;

  // Guard: can we play a card?
  if (rule.cardOrMove && hasMoved) {
    showStatus('Already moved — this faction plays cards OR moves, not both', 'error'); return;
  }
  // Magnus (Master Mason): can play 2 cards (or 1 card + 1 move)
  const maxCards = (champId === 'magnus') ? 2 : rule.cardPlays;
  if (cardsPlayedThisTurn >= maxCards) {
    showStatus('Card budget for this turn used up', 'error'); return;
  }
  // Soren (Fleetfoot): if already moved twice, no card allowed this turn
  if (champId === 'soren' && hasMoved && cardsPlayedThisTurn === 0 && gameState._sorenSecondMove) {
    showStatus('Already used both moves — no card this turn', 'error'); return;
  }

  // If a card is already pending (move/wall mode), clicking any card cancels it first.
  // Clicking the SAME card again deselects it.
  if (selectedCard && selectedCard.idx === idx && (uiMode === 'wall' || uiMode === 'move')) {
    selectedCard = null; uiMode = 'idle'; renderAll(); showStatus('Card deselected', ''); return;
  }
  // Clicking a DIFFERENT card while in move mode: cancel pending movement card (no cost)
  if (selectedCard && selectedCard._pendingMove && uiMode === 'move') {
    selectedCard = null; uiMode = 'idle';
  }
  // Clicking a DIFFERENT card while in wall/pick mode: cancel pending action (no cost)
  if (selectedCard && (uiMode === 'wall' || uiMode === 'wallPick' || uiMode === 'wallRedirect' || uiMode === 'wallSeal' || uiMode === 'wallPunch' || uiMode === 'wallReconstruct') && selectedCard.idx >= 0) {
    gameState._redeployCardIdx = null;
    gameState._redirectCardIdx = null;
    gameState._reconstructCardIdx = null;
    selectedCard = null; uiMode = 'idle';
  }

  selectedCard = { id: cardId, idx };

  if (card.type === 'Wall') {
    trackCategory('Wall');
    const isPhantom = !!(card.phantom);
    const isDurable = !!(card.durable);
    const length    = getCardWallLength(card.id);
    selectedCard = { ...selectedCard, length, isPhantom, isDurable };
    uiMode = 'wall';
    renderAll();
    showStatus(card.name + ' — click a wall edge to place', 'active');
  } else if (card.type === 'Movement') {
    trackCategory('Movement');
    applyMovementCard(pi, card, idx);
  } else if (card.type === 'Disruption') {
    trackCategory('Disruption');
    applyDisruptionCard(pi, card, idx);
  } else {
    discardCard(pi, idx);
    addLog(pi, 'card', 'Played: ' + card.name);
    selectedCard = null;
    countCardPlayed(pi);
    if (isTurnDone()) gameState.phase = 'end_turn';
    renderAll();
  }
  updateActionBar();
}

function countCardPlayed(pi) {
  cardsPlayedThisTurn++;
  hasPlayedCard = true;
  const champId = gameState.players[pi].champion.id;
  // Track categories for Adept synergies
  // (Called after selectCard resolves type)
}

function trackCategory(type) {
  if (type === 'Wall')       gameState._turnCategoryWall = true;
  if (type === 'Movement')   gameState._turnCategoryMovement = true;
  if (type === 'Disruption') gameState._turnCategoryDisruption = true;
  // Elara (Adepts) Equilibrium: drew 1 if wall + move in same turn (handled in onWallPlaced and executeMove)
  // Elara passive: if 2 different categories played this turn, draw 1
  const pi = gameState.activePlayer;
  const champId = gameState.players[pi].champion.id;
  if (champId === 'elara') {
    const cats = [gameState._turnCategoryWall, gameState._turnCategoryMovement, gameState._turnCategoryDisruption].filter(Boolean).length;
    if (cats >= 2 && !gameState._adeptEqDrawn) {
      gameState._adeptEqDrawn = true;
      drawCards(pi, 1);
      addLog(pi, 'passive', 'Omni-Arsenal: drew 1 for mixed-category turn');
    }
  }
  // Thorne (Wardens) — hand always revealed (handled in renderPanels)
}

function onWallPlaced(pi, fromCardId) {
  // T2 phantom step: don't count as a second card play
  const isT2Phantom = !!gameState._t2phantomPending;
  if (!isT2Phantom) countCardPlayed(pi);
  gameState._t2phantomPending = false;

  // Track last card played for Faction Mirror
  if (fromCardId && CARDS[fromCardId]) {
    gameState.lastOpponentCard = CARDS[fromCardId];
  }

  const card = CARDS[fromCardId];
  // Draw-on-place cards
  if (card?.drawOnPlace) drawCards(pi, card.drawOnPlace);

  // PH3 Echo Strike: after phantom wall on own side, also place a real mirrored wall on opponent's side
  if (fromCardId === 'PH3' && !gameState._echoStrikeReal) {
    gameState._echoStrikeReal = true;
    const lastWall = gameState.walls[gameState.walls.length - 1];
    if (lastWall) {
      // Mirror the anchor to the opposite side of the board
      const mirrorAnchor = lastWall.orientation === 'H'
        ? {row: BOARD_SIZE - 2 - lastWall.anchor.row, col: lastWall.anchor.col}
        : {row: lastWall.anchor.row, col: BOARD_SIZE - 2 - lastWall.anchor.col};
      if (isWallLegal(mirrorAnchor, lastWall.orientation, lastWall.length, gameState.walls,
          gameState.players[0].position, gameState.players[1].position, false)) {
        selectedCard = { id:'PH3_real', idx:-1, length:lastWall.length, isPhantom:false, isDurable:false };
        executePlaceWall(mirrorAnchor, lastWall.orientation, lastWall.length, false, false, '');
        addLog(pi, 'card', 'Echo Strike: real mirrored wall placed on opponent side');
      }
    }
    gameState._echoStrikeReal = false;
    return;
  }

  // PH4 Veil Lattice: place 2 phantom walls
  if (fromCardId === 'PH4') {
    if (!gameState._veilCount) gameState._veilCount = 0;
    gameState._veilCount++;
    if (gameState._veilCount < 2) {
      selectedCard = { id:'PH4', idx:-1, length:2, isPhantom:true, isDurable:false };
      uiMode = 'wall';
      renderAll(); showStatus('Veil Lattice: place the 2nd Phantom Wall (persists until walked through)', 'active'); return;
    }
    gameState._veilCount = 0;
  }

  // CB / S4 Corner Piece: after first 2-tile wall, enter perpendicular 2-tile placement
  if ((fromCardId === 'CB' || fromCardId === 'S4') && !gameState._cornerSecond) {
    gameState._cornerSecond = true;
    wallOrientation = (wallOrientation === 'H') ? 'V' : 'H';
    selectedCard = { id:'CB_second', idx:-1, length:2, isPhantom:false, isDurable:false };
    uiMode = 'wall';
    renderAll(); showStatus('Corner Block: now place the perpendicular 2-tile wall', 'active'); return;
  }
  gameState._cornerSecond = false;

  // AD5 Synthesis Wall: if played both Movement and Disruption this turn, wall gains Reinforce
  if (fromCardId === 'AD5') {
    const lastWall = gameState.walls[gameState.walls.length - 1];
    if (lastWall && gameState._turnCategoryMovement && gameState._turnCategoryDisruption) {
      gameState.walls = gameState.walls.map(w =>
        w.id === lastWall.id ? {...w, reinforced:true, immune:true} : w
      );
      addLog(pi, 'card', 'Synthesis Wall: reinforced due to mixed-category turn!');
    }
  }

  // AD1 Flexible Form: if both a wall and a move happened this turn, draw 1 (Equilibrium)
  if (fromCardId === 'AD1' && hasMoved) {
    drawCards(pi, 1); addLog(pi, 'passive', 'Equilibrium: drew 1 from Flexible Form');
  }

  opponentLastPlayedWall = (pi !== 0);
  if (isTurnDone()) gameState.phase = 'end_turn';
  renderAll(); updateActionBar();
}

function isAdjacentToExistingWall(wall, others) {
  for (const w of others) {
    if (w.isPhantom) continue;
    if (w.orientation !== wall.orientation) continue;
    const dr = Math.abs(wall.anchor.row - w.anchor.row);
    const dc = Math.abs(wall.anchor.col - w.anchor.col);
    if (wall.orientation === 'H' && dr === 0 && dc <= Math.max(wall.length, w.length)+1) return true;
    if (wall.orientation === 'V' && dc === 0 && dr <= Math.max(wall.length, w.length)+1) return true;
  }
  return false;
}

function drawCards(pi, n) {
  const p = gameState.players[pi];
  const maxHand = p.champion.handSize;
  const available = Math.max(0, maxHand - p.hand.length);
  n = Math.min(n, available); // never draw above hand limit
  if (n <= 0) return;
  let deck = [...p.deck], discard = [...p.discard];
  const drawn = [];
  for (let i = 0; i < n; i++) {
    if (!deck.length) { if (!discard.length) break; deck = shuffle([...discard]); discard = []; }
    drawn.push(deck.shift());
  }
  if (drawn.length) {
    const hand = [...p.hand, ...drawn];
    gameState.players[pi] = { ...p, deck, discard, hand };
    addLog(pi, 'draw', 'Drew ' + drawn.length + ': ' + drawn.filter(x=>x&&x.name).map(c=>c.name).join(', '));
  }
}

// ── Movement card handler ─────────────────────────────────────────────
function applyMovementCard(pi, card, idx) {
  // Don't discard or count yet — player must confirm by selecting a destination.
  // They can click a different card to cancel this selection.
  let speed = card.overrideSpeed || gameState.players[pi].champion.moveSpeed;
  if (card.reactive && opponentLastPlayedWall) speed = 3;
  // Store pending card info; discard+count happens in executeMove
  selectedCard = { id: card.id, idx, overrideSpeed: speed, tunnelThrough: !!card.tunnel, _pendingMove: true };
  uiMode = 'move';
  renderAll();
  showStatus(card.name + ' — select destination (' + speed + ' step' + (speed>1?'s':'') + '), or click another card to cancel', 'active');
}

// ── Disruption card handler ───────────────────────────────────────────
function applyDisruptionCard(pi, card, idx) {
  const opp = 1 - pi;

  // ── A3: Reclaim — pick up oldest own wall, shuffle a Standard Wall into deck ──
  // The reclaimed card enters the deck (available next turn), not the hand,
  // so the player doesn't get a second card play this turn.
  if (card.id === 'A3') {
    const myWalls = gameState.walls.filter(w => w.owner===pi && !w.isPhantom && !w.permanent)
                                   .sort((a,b) => a.placedOnTurn - b.placedOnTurn);
    if (!myWalls.length) { showStatus('No walls to reclaim', 'error'); return; }
    const target = myWalls[0];
    gameState.walls = gameState.walls.filter(w => w.id !== target.id);
    gameState.players[pi] = { ...gameState.players[pi],
      wallsInPlay: Math.max(0, gameState.players[pi].wallsInPlay - 1) };
    // Discard the Reclaim card first (before modifying hand/deck)
    discardCard(pi, idx);
    // Shuffle a Standard Wall card into the deck for next turn
    const stdWall = {...CARDS['A1']};
    const p2 = gameState.players[pi];
    const insertAt = Math.floor(Math.random() * (p2.deck.length + 1));
    const newDeck = [...p2.deck];
    newDeck.splice(insertAt, 0, stdWall);
    gameState.players[pi] = { ...p2, deck: newDeck };
    selectedCard = null; countCardPlayed(pi);
    addLog(pi, 'card', 'Reclaim: wall removed, Standard Wall shuffled into deck');
    if (isTurnDone()) gameState.phase = 'end_turn';
    renderAll(); showStatus('Wall reclaimed — Standard Wall shuffled into your deck!', 'success'); return;
  }

  // ── A4: Redeploy — click one of your walls on the board to pick it up ──
  if (card.id === 'A4') {
    const myWalls = gameState.walls.filter(w => w.owner===pi && !w.isPhantom && !w.permanent);
    if (!myWalls.length) { showStatus('No walls to redeploy', 'error'); return; }
    // Enter wall-pick mode: player clicks a wall on the board to lift it
    gameState._redeployCardIdx = idx;
    uiMode = 'wallPick';
    selectedCard = { id:'A4', idx };
    renderAll();
    showStatus('Redeploy — click one of your walls on the board to lift it', 'active');
    return;
  }

  // ── AR2: Reinforce Wall — click one of your walls to reinforce it ──
  if (card.id === 'A5' || card.id === 'AR2') {
    const myWalls = gameState.walls.filter(w => w.owner===pi && !w.isPhantom && !w.reinforced);
    if (!myWalls.length) { showStatus('No walls to reinforce', 'error'); return; }
    // Enter wallReinforce mode — player clicks which wall to reinforce
    gameState._reinforceCardIdx = idx;
    uiMode = 'wallReinforce';
    selectedCard = { id: card.id, idx };
    renderAll();
    showStatus('Reinforce — click one of your walls to make it immune to destruction and movement', 'active');
    return;
  }

  // ── T5 / general: Punch Through — click any non-permanent, non-reinforced wall to remove 1 tile ──
  if (card.id === 'T5') {
    const breakable = gameState.walls.filter(w => !w.isPhantom && !w.permanent && !w.reinforced && !w.immune);
    if (!breakable.length) { showStatus('No walls to punch through', 'error'); return; }
    gameState._punchCardIdx = idx;
    uiMode = 'wallPunch';
    selectedCard = { id:'T5', idx };
    renderAll();
    showStatus('Punch Through — click any non-reinforced wall to remove one tile (destroys 1-tile walls)', 'active');
    return;
  }

  // ── WD3: Eviction — move 1 non-reinforced opponent wall to any legal location ──
  if (card.id === 'WD3') {
    const oppWalls = gameState.walls.filter(w => w.owner===opp && !w.isPhantom && !w.permanent && !w.reinforced && !w.immune);
    if (!oppWalls.length) { showStatus("No moveable opponent walls (reinforced walls are immune)", 'error'); return; }
    gameState._redirectCardIdx = idx;
    uiMode = 'wallRedirect';
    selectedCard = { id:'WD3', idx };
    renderAll();
    showStatus('Eviction — click a non-reinforced opponent wall to relocate it', 'active');
    return;
  }

  // ── WD2: Tax Notice — opponent discards 1 card if they have 3+ walls ──
  if (card.id === 'WD2') {
    const op = gameState.players[opp];
    if (gameState.walls.filter(w => w.owner===opp && !w.isPhantom).length < 3) {
      showStatus('Tax Notice requires opponent to have 3+ walls', 'error'); return;
    }
    if (op.hand.length) {
      // Player (human) picks which card; for simplicity discard first (could be improved to let player choose)
      const ridx = Math.floor(Math.random() * op.hand.length);
      const gone = op.hand[ridx];
      gameState.players[opp] = { ...op,
        hand: op.hand.filter((_,i)=>i!==ridx), discard:[...op.discard, gone] };
      addLog(pi, 'card', 'Tax Notice: opponent discarded ' + gone.name);
    } else {
      addLog(pi, 'card', 'Tax Notice: opponent hand was empty');
    }
    drawCards(pi, 1);
    discardCard(pi, idx); selectedCard = null; countCardPlayed(pi);
    if (isTurnDone()) gameState.phase = 'end_turn';
    renderAll(); showStatus('Tax Notice: opponent discarded!', 'success'); return;
  }

  // ── WD4: Confiscate — opponent discards 2 cards, no draw for player ──
  if (card.id === 'WD4') {
    const op = gameState.players[opp];
    const discardCount = Math.min(2, op.hand.length);
    if (discardCount > 0) {
      // Discard 2 random cards from opponent's hand
      let hand = [...op.hand];
      const discarded = [];
      for (let i = 0; i < discardCount; i++) {
        const ridx = Math.floor(Math.random() * hand.length);
        discarded.push(hand.splice(ridx, 1)[0]);
      }
      gameState.players[opp] = { ...op, hand, discard: [...op.discard, ...discarded] };
      addLog(pi, 'card', `Confiscate: opponent discarded ${discarded.map(c=>c.name).join(', ')}!`);
    } else {
      addLog(pi, 'card', 'Confiscate: opponent hand was empty');
    }
    discardCard(pi, idx); selectedCard = null; countCardPlayed(pi);
    if (isTurnDone()) gameState.phase = 'end_turn';
    renderAll(); showStatus(`Confiscate: opponent discarded ${discardCount} card(s)!`, 'success'); return;
  }

  // ── WD5: Total Seizure — move ALL opponent walls (bypasses Reinforce) ──
  if (card.id === 'WD5') {
    // AI-side: just place them randomly; Human: simplified to random legal placement
    const oppWalls = [...gameState.walls.filter(w => w.owner===opp && !w.isPhantom)];
    let moved = 0;
    for (const w of oppWalls) {
      gameState.walls = gameState.walls.filter(x => x.id !== w.id);
      // Try to find a legal new position for each wall
      const candidates = generateWallCandidates(gameState.players[0].position, w.length);
      let placed = false;
      for (const {anchor, orientation} of shuffle(candidates)) {
        if (isWallLegal(anchor, orientation, w.length, gameState.walls,
            gameState.players[0].position, gameState.players[1].position, false)) {
          gameState.walls.push({...w, anchor, orientation});
          moved++;
          placed = true;
          break;
        }
      }
      // If can't find new position, restore wall in place (don't delete it)
      if (!placed) gameState.walls.push({...w});
    }
    addLog(pi, 'card', `Total Seizure: relocated ${moved} opponent walls!`);
    discardCard(pi, idx); selectedCard = null; countCardPlayed(pi);
    if (isTurnDone()) gameState.phase = 'end_turn';
    renderAll(); showStatus(`Total Seizure: moved ${moved} opponent walls!`, 'success'); return;
  }

  // ── PH2: Compel — force opponent to move 1 space (not voluntary, no phantom removal) ──
  if (card.id === 'PH2') {
    const dirs = [{r:-1,c:0,label:'UP ↑'},{r:1,c:0,label:'DOWN ↓'},{r:0,c:1,label:'RIGHT →'},{r:0,c:-1,label:'LEFT ←'}];
    const oppPos = gameState.players[opp].position;
    const blocked = buildBlockedEdges(gameState.walls, opp);
    const legalDirs = dirs.filter(d => {
      const nb = {row:oppPos.row+d.r, col:oppPos.col+d.c};
      return nb.row>=0&&nb.row<BOARD_SIZE&&nb.col>=0&&nb.col<BOARD_SIZE && !isEdgeBlocked(oppPos, nb, blocked);
    });
    if (!legalDirs.length) {
      discardCard(pi, idx); selectedCard = null; countCardPlayed(pi);
      if (isTurnDone()) gameState.phase = 'end_turn';
      renderAll(); showStatus('Compel: opponent had no legal moves to force', 'success'); return;
    }
    // Show direction picker modal
    showDirectionPicker(legalDirs, (chosen) => {
      const newPos = {row:oppPos.row+chosen.r, col:oppPos.col+chosen.c};
      gameState.players[opp] = {...gameState.players[opp], position: newPos};
      addLog(pi, 'card', `Compel: forced opponent ${chosen.label} to (${newPos.row},${newPos.col})`);
      discardCard(pi, idx); selectedCard = null; countCardPlayed(pi);
      if (isTurnDone()) gameState.phase = 'end_turn';
      renderAll(); showStatus('Compel: opponent forced to move!', 'success');
    });
    return;
  }

  // ── PH5: Compel Storm — force opponent up to 3 steps (no phantom removal) ──
  if (card.id === 'PH5') {
    const dirs = [{r:-1,c:0},{r:1,c:0},{r:0,c:1},{r:0,c:-1}];
    let pos = {...gameState.players[opp].position};
    for (let step = 0; step < 3; step++) {
      const blocked = buildBlockedEdges(gameState.walls.filter(w => !w.isPhantom), opp);
      const legalDirs = dirs.filter(d => {
        const nb = {row:pos.row+d.r, col:pos.col+d.c};
        return nb.row>=0&&nb.row<BOARD_SIZE&&nb.col>=0&&nb.col<BOARD_SIZE && !isEdgeBlocked(pos, nb, blocked);
      });
      if (!legalDirs.length) break;
      const chosen = legalDirs[Math.floor(Math.random() * legalDirs.length)];
      pos = {row:pos.row+chosen.r, col:pos.col+chosen.c};
    }
    gameState.players[opp] = {...gameState.players[opp], position: pos};
    addLog(pi, 'card', `Compel Storm: forced opponent up to 3 spaces to (${pos.row},${pos.col})`);
    discardCard(pi, idx); selectedCard = null; countCardPlayed(pi);
    if (isTurnDone()) gameState.phase = 'end_turn';
    renderAll(); showStatus('Compel Storm: opponent blasted 3 spaces!', 'success'); return;
  }

  // ── AD4: Faction Mirror — copy the last card the opponent played ──
  if (card.id === 'AD4') {
    const lastOppCard = gameState.lastOpponentCard;
    if (!lastOppCard) { showStatus('No opponent card to copy', 'error'); return; }
    // Inject a copy of opponent's last card into hand and "play" it
    addLog(pi, 'card', `Faction Mirror: copying opponent's ${lastOppCard.name}`);
    discardCard(pi, idx);
    // Add to hand temporarily and select it
    const mirrored = {...lastOppCard};
    gameState.players[pi] = {...gameState.players[pi], hand: [...gameState.players[pi].hand, mirrored]};
    const mirroredIdx = gameState.players[pi].hand.length - 1;
    // Directly call selectCard to execute the mirrored card
    selectCard(mirrored.id, mirroredIdx);
    return;
  }

  // ── AR3: Blueprint Shift — pick up own wall and re-place it anywhere legal ──
  if (card.id === 'AR3') {
    const myWalls = gameState.walls.filter(w => w.owner===pi && !w.isPhantom && !w.permanent && !w.reinforced);
    if (!myWalls.length) { showStatus('No moveable walls to shift', 'error'); return; }
    gameState._redeployCardIdx = idx;
    gameState._redeployCardId = 'AR3';
    uiMode = 'wallPick';
    selectedCard = { id:'AR3', idx };
    renderAll();
    showStatus('Blueprint Shift — click one of your walls to lift and re-place it', 'active'); return;
  }

  // ── RC: Reconstruction — pick own wall to remove, draw 1 ──
  if (card.id === 'RC') {
    const myWalls = gameState.walls.filter(w => w.owner===pi && !w.isPhantom);
    if (!myWalls.length) { showStatus('No walls to remove', 'error'); return; }
    // Enter wallPick mode — player clicks which wall to reconstruct
    gameState._reconstructCardIdx = idx;
    uiMode = 'wallReconstruct';
    selectedCard = { id:'RC', idx };
    renderAll();
    showStatus('Reconstruction — click one of your walls to remove it and draw 1', 'active'); return;
  }

  // ── T3 / old Redirect ──
  if (card.id === 'T3') {
    const oppWalls = gameState.walls.filter(w => w.owner===opp && !w.isPhantom && !w.permanent && !w.reinforced);
    if (!oppWalls.length) { showStatus("No opponent walls to redirect", 'error'); return; }
    gameState._redirectCardIdx = idx;
    uiMode = 'wallRedirect';
    selectedCard = { id:'T3', idx };
    renderAll();
    showStatus('Redirect — click an opponent wall to pick it up and relocate it', 'active');
    return;
  }

  // ── T4: Scatter — opponent discards 1 random card ──
  if (card.id === 'T4') {
    const op = gameState.players[opp];
    if (op.hand.length) {
      const ridx = Math.floor(Math.random() * op.hand.length);
      const gone = op.hand[ridx];
      gameState.players[opp] = { ...op,
        hand: op.hand.filter((_,i)=>i!==ridx), discard:[...op.discard, gone] };
      addLog(pi, 'card', 'Scatter: opponent discarded ' + gone.name);
    } else {
      addLog(pi, 'card', 'Scatter: opponent hand was empty');
    }
    discardCard(pi, idx); selectedCard = null; countCardPlayed(pi);
    if (isTurnDone()) gameState.phase = 'end_turn';
    renderAll(); showStatus('Scatter: opponent discarded!', 'success'); return;
  }

  // ── S5: Seal — click one of your walls to make it permanent ──
  if (card.id === 'S5') {
    const myWalls = gameState.walls.filter(w => w.owner===pi && !w.isPhantom && !w.permanent);
    if (!myWalls.length) { showStatus('No walls to seal', 'error'); return; }
    gameState._sealCardIdx = idx;
    uiMode = 'wallSeal';
    selectedCard = { id:'S5', idx };
    renderAll();
    showStatus('Seal — click one of your walls to make it permanent', 'active'); return;
  }

  // Generic fallback
  discardCard(pi, idx); addLog(pi, 'card', 'Played: ' + card.name);
  selectedCard = null; countCardPlayed(pi);
  if (isTurnDone()) gameState.phase = 'end_turn';
  renderAll(); showStatus(card.name + ' played', 'success');
}

// ── Ultimates ────────────────────────────────────────────────────────
function activateUltimate(pi) {
  if (pi === AI_PLAYER) return;
  if (gameState.phase !== 'action' || gameState.activePlayer !== pi) {
    showStatus('Not your action phase', 'error'); return;
  }
  const p = gameState.players[pi];
  if (!p.ultimateReady) { showStatus('Ultimate not charged', 'error'); return; }
  if (p.ultimateUsed)   { showStatus('Already used this match', 'error'); return; }
  gameState.players[pi] = { ...p, ultimateUsed:true, ultimateReady:false, ultimateCharge:0 };
  applyUltimate(pi, gameState.players[pi].champion.id);
}

function applyUltimate(pi, champId) {
  const opp = 1 - pi;
  switch(champId) {
    case 'magnus':
      // Living Blueprint: discard hand, refill to full
      gameState.players[pi] = { ...gameState.players[pi],
        discard: [...gameState.players[pi].discard, ...gameState.players[pi].hand],
        hand: [] };
      drawCards(pi, gameState.players[pi].champion.handSize);
      addLog(pi,'ultimate','Living Blueprint: hand discarded and refilled');
      showStatus('Living Blueprint — hand refreshed!','success'); break;

    case 'soren':
      // Stormpath: ignore all walls this turn (set a flag, check in getLegalMoves)
      gameState.players[pi] = { ...gameState.players[pi], stormpath: true };
      hasMoved = false; // grant a fresh move
      addLog(pi,'ultimate','Stormpath: ignore all walls this turn — move freely!');
      showStatus('Stormpath — walls are meaningless this turn!','success');
      renderAll(); return; // skip countCardPlayed; handled when move completes

    case 'thorne': {
      // Total Reordering: reposition all walls to random legal locations
      const allWalls = [...gameState.walls.filter(w => !w.isPhantom)];
      for (const w of allWalls) {
        gameState.walls = gameState.walls.filter(x => x.id !== w.id);
        const cands = generateWallCandidates(gameState.players[0].position, w.length);
        let placed = false;
        for (const {anchor, orientation} of shuffle(cands)) {
          if (isWallLegal(anchor, orientation, w.length, gameState.walls,
              gameState.players[0].position, gameState.players[1].position, false)) {
            gameState.walls.push({...w, anchor, orientation});
            placed = true;
            break;
          }
        }
        // If can't place, restore original — don't lose the wall
        if (!placed) {
          gameState.walls.push({...w});
        }
      }
      addLog(pi,'ultimate','Total Reordering: all walls repositioned');
      showStatus('Total Reordering — entire board reshuffled!','success'); break;
    }

    case 'nyx':
      // Veil of Shadows: invisible for 3 turns (render them hidden for opponent)
      gameState.players[pi] = {...gameState.players[pi],
        statusEffects:[...(gameState.players[pi].statusEffects||[]),{type:'veil_of_shadows',turnsRemaining:3}]};
      addLog(pi,'ultimate','Veil of Shadows: invisible for 3 turns');
      showStatus('Veil of Shadows — you disappear!','success'); break;

    case 'elara': {
      // Faction Forge: generate 3 random faction cards, play one for free
      const factions = ['Architects','Pathfinders','Wardens','Phantoms'];
      const shuffle3 = shuffle(factions).slice(0,3);
      const generated = shuffle3.map(f => {
        const fc = Object.values(CARDS).filter(c => c.faction === f);
        return fc[Math.floor(Math.random() * fc.length)];
      }).filter(Boolean);
      if (generated.length) {
        // Add them to hand temporarily (player can choose to play one)
        gameState.players[pi] = {...gameState.players[pi],
          hand: [...gameState.players[pi].hand, ...generated]};
        addLog(pi,'ultimate','Faction Forge: generated ' + generated.map(c=>c.name).join(', '));
        showStatus('Faction Forge — choose one card to play from your hand!','success');
      }
      break;
    }

    // Legacy fallback for old champion IDs (safety)
    case 'vael':
      gameState.players[pi] = { ...gameState.players[pi], wallLimitCurrent: gameState.players[pi].wallLimitCurrent+3 };
      addLog(pi,'ultimate','Grand Barricade: +3 wall slots this turn');
      showStatus('Grand Barricade — 3 extra walls this turn!','success'); break;
    case 'maren':
      gameState.players[pi]={...gameState.players[pi],wallLimitCurrent:gameState.players[pi].wallLimitCurrent+4};
      addLog(pi,'ultimate','Lockdown: +4 wall slots');
      showStatus('Lockdown — place 4 extra walls!','success'); break;
  }
  // Ultimates do NOT consume the card-play budget — player can still move and play a card
  if (isTurnDone()) gameState.phase = 'end_turn';
  renderAll(); updateActionBar();
}

function maybeAIUltimate(pi) {
  const p = gameState.players[pi];
  if (!p.ultimateReady || p.ultimateUsed) return false;
  gameState.players[pi] = { ...p, ultimateUsed:true, ultimateReady:false, ultimateCharge:0 };
  applyUltimate(pi, p.champion.id);
  return true;
}
function onEndTurnPassives(pi) {
  const champId = gameState.players[pi].champion.id;
  const p = gameState.players[pi];
  // Reset wall limit to base if it was temporarily increased
  if (p.wallLimitCurrent > p.champion.wallLimit)
    gameState.players[pi] = { ...gameState.players[pi], wallLimitCurrent: p.champion.wallLimit };
  if (pi !== 0) opponentLastPlayedWall = cardsPlayedThisTurn > 0;
  // Clear stormpath at end of turn (safety)
  if (gameState.players[pi].stormpath)
    gameState.players[pi] = {...gameState.players[pi], stormpath: false};

  // ── Binding Wall: check if this player ends adjacent to an opponent's binding wall ──
  // A player is Bound only if they are NOT already on skip_move cooldown.
  // After the skip_move resolves, a 1-turn bind_cooldown is granted so the player can escape.
  const opp = 1 - pi;
  const pos = gameState.players[pi].position;
  const oppBindingWalls = gameState.walls.filter(w => w.binding && w.owner === opp && !w.isPhantom);
  const isAdjacent = oppBindingWalls.some(w =>
    wallEdges(w).some(e =>
      (e.a.row === pos.row && e.a.col === pos.col) ||
      (e.b.row === pos.row && e.b.col === pos.col)
    )
  );
  if (isAdjacent) {
    const currentEffects = gameState.players[pi].statusEffects || [];
    const hasSkip     = currentEffects.some(e => e.type === 'skip_move'     && e.turnsRemaining > 0);
    const hasCooldown = currentEffects.some(e => e.type === 'bind_cooldown' && e.turnsRemaining > 0);
    if (!hasSkip && !hasCooldown) {
      gameState.players[pi] = {
        ...gameState.players[pi],
        statusEffects: [...currentEffects, { type:'skip_move', turnsRemaining:1 }],
      };
      addLog(pi, 'system', `Bound! Adjacent to a Binding Wall — move skipped next turn.`);
    }
  }
}

function updateUltimateButton(pi) {
  const btn = document.getElementById('p'+pi+'-ult-btn');
  if (!btn) return;
  const p = gameState.players[pi];
  const ready    = p.ultimateReady && !p.ultimateUsed;
  const isMyTurn = gameState.activePlayer===pi && gameState.phase==='action' && pi!==AI_PLAYER;
  btn.disabled           = !(ready && isMyTurn);
  btn.style.opacity      = (ready && isMyTurn) ? '1' : '0.3';
  btn.style.pointerEvents= (ready && isMyTurn) ? 'auto' : 'none';
  btn.style.borderColor  = ready ? 'var(--amber)' : '';
  btn.style.color        = ready ? 'var(--amber)' : '';
  btn.textContent = p.ultimateUsed ? '⚡ USED' : ready ? '⚡ ACTIVATE ULTIMATE' : '⚡ CHARGING...';
}

function updateActionBar() {
  const phase = gameState.phase;
  const isAction = phase === 'action';
  const isHuman = gameState.activePlayer !== AI_PLAYER;

  const btnMove = document.getElementById('btn-move');
  const btnEnd  = document.getElementById('btn-end');

  if (btnMove) {
    const pi = gameState.activePlayer;
    const champId = isHuman && gameState.players[pi] ? gameState.players[pi].champion.id : null;
    // Soren can take a second move if no card played yet and hasn't used second move
    const sorenCanMoveAgain = champId === 'soren' && hasMoved && cardsPlayedThisTurn === 0 && !gameState._sorenSecondMove;
    const isBound = isHuman && (gameState.players[pi]?.statusEffects || []).some(e => e.type === 'skip_move' && e.turnsRemaining > 0);
    btnMove.disabled = !isAction || (hasMoved && !sorenCanMoveAgain) || !isHuman || aiThinking || isBound;
    btnMove.className = `action-btn primary${uiMode==='move' ? ' active' : ''}`;
    if (isBound) btnMove.textContent = 'BOUND';
    else if (sorenCanMoveAgain) btnMove.textContent = 'MOVE (2nd)';
    else btnMove.textContent = 'MOVE';
  }
  if (btnEnd) {
    btnEnd.disabled = phase==='draw' || phase==='ended' || aiThinking;
  }
}

// ── Rendering ───────────────────────────────────────────────────────
function renderAll() {
  renderPanels();
  renderBoard();
  renderLog();
  updateTurnBanner();
  updateActionBar();
  updateUltimateButton(0);
  updateUltimateButton(1);
  if (debugVisible) updateDebug();
}

function renderPanels() {
  for (const pi of [0,1]) {
    const p = gameState.players[pi];
    const def = p.champion;
    const prefix = `p${pi}`;

    setText(`${prefix}-name`, def.name);
    setText(`${prefix}-title`, def.title);
    setText(`${prefix}-faction`, def.faction);
    setText(`${prefix}-walls`, `${p.wallsInPlay}/${p.wallLimitCurrent}`);
    setText(`${prefix}-hand-count`, `${p.hand.length}/${def.handSize}`);
    setText(`${prefix}-speed`, def.moveSpeed);
    setText(`${prefix}-draw`, def.cardDraw);
    setText(`${prefix}-deck-count`, `(deck: ${p.deck.length})`);
    setText(`${prefix}-ult-name`, def.ultimateName);
    setText(`${prefix}-passive-name`, def.passiveName);
    setText(`${prefix}-passive-desc`, def.passiveDesc);
    setText(`${prefix}-charge-text`, `${p.ultimateCharge} / ${def.ultimateCost}`);

    const badge = document.getElementById(`${prefix}-faction`);
    if (badge) badge.className = `faction-badge faction-${def.faction}`;

    renderChargeBar(`${prefix}-charge-bar`, p.ultimateCharge, def.ultimateCost, p.ultimateReady);
    renderWallPips(`${prefix}-wall-pips`, p.wallsInPlay, p.wallLimitCurrent);

    // Status chips
    const statusEl = document.getElementById(`${prefix}-status`);
    if (statusEl) {
      statusEl.innerHTML = p.statusEffects.filter(e=>e.turnsRemaining>0)
        .map(e => {
          const labels = { skip_move:'BOUND', bind_cooldown:'COOLDOWN', veil_of_shadows:'VEILED' };
          const label = labels[e.type] || e.type.replace(/_/g,' ').toUpperCase();
          return `<span class="status-chip">${label} (${e.turnsRemaining}t)</span>`;
        }).join('');
    }

    // Hand — player 0 always sees own cards; AI hand shown as hidden (unless Thorne's Stare)
    const handEl = document.getElementById(`${prefix}-hand`);
    if (handEl) {
      const isThorne = gameState.players[0].champion.id === 'thorne' && pi === AI_PLAYER;
      if (pi === AI_PLAYER && !isThorne) {
        handEl.innerHTML = p.hand.map(()=>
          `<div class="hidden-card"><div class="hidden-card-icon"></div><span class="hidden-card-label">HIDDEN</span></div>`
        ).join('');
      } else {
        const isActive = pi === gameState.activePlayer && gameState.phase === 'action' && pi !== AI_PLAYER;
        handEl.innerHTML = p.hand.map((card,idx) => renderCard(card, idx, pi, isActive)).join('');
      }
    }
  }
}

function renderCard(card, idx, pi, interactive) {
  const isSel = selectedCard && selectedCard.idx === idx;
  const cls = `card${isSel?' selected':''}${!interactive?' card-disabled':''}`;
  return `<div class="${cls}" onclick="${interactive?`selectCard('${card.id}',${idx})`:''}">
    <div class="card-header">
      <span class="card-name"><span class="rarity-dot rarity-${card.rarity}"></span>${card.name}</span>
      <span class="card-type-badge type-${card.type}">${card.type}</span>
    </div>
    <div class="card-desc">${card.desc}</div>
  </div>`;
}

function renderChargeBar(id, charge, cost, ready) {
  const el = document.getElementById(id);
  if (!el) return;
  el.innerHTML = Array.from({length:cost},(_,i) => {
    const cls = i<charge ? (ready?'charge-pip ready':'charge-pip filled') : 'charge-pip';
    return `<div class="${cls}"></div>`;
  }).join('');
}

function renderWallPips(id, inPlay, limit) {
  const el = document.getElementById(id);
  if (!el) return;
  el.innerHTML = Array.from({length:limit},(_,i)=>
    `<div class="wall-pip${i<inPlay?' filled':''}"></div>`).join('');
}

function renderBoard() {
  const container = document.getElementById('board-container');
  if (!container) return;

  const totalSize = BOARD_SIZE*CELL + (BOARD_SIZE-1)*GAP;

  const p0Name = gameState.players[0].champion.name.toUpperCase();
  const p1Name = gameState.players[1].champion.name.toUpperCase();
  container.innerHTML = `
    <div style="position:absolute;top:-20px;left:0;right:0;text-align:center;font-size:9px;color:var(--p1-dim);letter-spacing:.15em;font-family:'JetBrains Mono',monospace;">← AI (${p1Name}) GOAL →</div>
    <div class="board-grid" id="board-grid"></div>
    <div class="wall-layer" id="wall-layer" style="position:absolute;top:${GAP}px;left:${GAP}px;width:${totalSize}px;height:${totalSize}px;"></div>
    <div id="wall-overlay" style="position:absolute;top:${GAP}px;left:${GAP}px;width:${totalSize}px;height:${totalSize}px;pointer-events:none;"></div>
    <div style="position:absolute;bottom:-20px;left:0;right:0;text-align:center;font-size:9px;color:var(--amber-dim);letter-spacing:.15em;font-family:'JetBrains Mono',monospace;">← YOUR (${p0Name}) GOAL →</div>
  `;

  const grid = document.getElementById('board-grid');
  const overrideSpeed = selectedCard && selectedCard.overrideSpeed;
  const legalMoves = uiMode==='move' ? getLegalMoves(gameState, gameState.activePlayer, overrideSpeed) : [];
  const legalSet = new Set(legalMoves.map(m=>`${m.row},${m.col}`));

  for (let r=0; r<BOARD_SIZE; r++) {
    for (let c=0; c<BOARD_SIZE; c++) {
      const isLegal = legalSet.has(`${r},${c}`);
      const cell = document.createElement('div');
      cell.className = `cell${isLegal?' legal-move':''}${r===0?' goal-row-p0':''}${r===BOARD_SIZE-1?' goal-row-p1':''}`;
      cell.dataset.row = r; cell.dataset.col = c;
      if (isLegal) cell.onclick = () => handleCellClick(r, c);
      grid.appendChild(cell);
    }
  }

  // Pieces
  for (const pi of [0,1]) {
    const pos = gameState.players[pi].position;
    const cellEl = grid.children[pos.row*BOARD_SIZE + pos.col];
    if (cellEl) {
      const isActive = pi===gameState.activePlayer && !aiThinking;
      const piece = document.createElement('div');
      piece.className = `champion-piece p${pi}${isActive?' active-piece':''}`;
      piece.textContent = gameState.players[pi].champion.name[0];
      cellEl.appendChild(piece);
    }
  }

  renderWalls();
  if (uiMode==='wall' && selectedCard) renderWallHotspots();
  if (uiMode==='wallPick') { /* walls rendered with pick handlers above */ }
}

function renderWalls() {
  const layer = document.getElementById('wall-layer');
  if (!layer) return;
  layer.innerHTML = '';
  // Toggle pick-mode class to enable/disable clicks
  if (uiMode === 'wallPick' || uiMode === 'wallRedirect' || uiMode === 'wallSeal' || uiMode === 'wallPunch' || uiMode === 'wallReinforce' || uiMode === 'wallReconstruct') {
    layer.classList.add('pick-mode');
  } else {
    layer.classList.remove('pick-mode');
  }

  for (const wall of gameState.walls) {

    const el = document.createElement('div');
    const isPickable    = uiMode === 'wallPick'      && wall.owner === 0 && !wall.isPhantom && !wall.permanent;
    const isRedirect    = uiMode === 'wallRedirect'  && wall.owner === 1 && !wall.isPhantom && !wall.permanent;
    const isSealable    = uiMode === 'wallSeal'      && wall.owner === 0 && !wall.isPhantom && !wall.permanent;
    const isPunchable   = uiMode === 'wallPunch'     && !wall.isPhantom && !wall.permanent && !wall.reinforced && !wall.immune;
    const isReinforceable = uiMode === 'wallReinforce' && wall.owner === gameState.activePlayer && !wall.isPhantom && !wall.reinforced;
    const isReconstructable = uiMode === 'wallReconstruct' && wall.owner === gameState.activePlayer && !wall.isPhantom;
    // Owner of a phantom wall sees it with a distinct teal tint (only player 0 = human)
    const isOwnPhantom = wall.isPhantom && wall.owner === 0;
    let cls = `wall-segment${wall.isPhantom?' phantom':''} owner-${wall.owner}${isOwnPhantom?' phantom-own':''}`;
    if (wall.immune || wall.permanent || wall.reinforced) cls += ' wall-immune';
    if (wall.reinforced) cls += ' wall-reinforced';
    if (wall.binding) cls += ' wall-binding';
    if (isPickable)       cls += ' wall-pickable';
    if (isRedirect)       cls += ' wall-pickable wall-redirect';
    if (isSealable)       cls += ' wall-pickable wall-sealable';
    if (isPunchable)      cls += ' wall-pickable wall-punchable';
    if (isReinforceable)  cls += ' wall-pickable wall-reinforceable';
    if (isReconstructable) cls += ' wall-pickable wall-reconstructable';
    el.className = cls;
    Object.assign(el.style, wallVisualPos(wall));

    if (isPickable) {
      el.style.cursor = 'pointer';
      el.addEventListener('click', () => pickWallForRedeploy(wall));
    }
    if (isRedirect) {
      el.style.cursor = 'pointer';
      el.addEventListener('click', () => pickWallForRedirect(wall));
    }
    if (isSealable) {
      el.style.cursor = 'pointer';
      el.addEventListener('click', () => pickWallForSeal(wall));
    }
    if (isReinforceable) {
      el.style.cursor = 'pointer';
      el.addEventListener('click', () => pickWallForReinforce(wall));
    }
    if (isReconstructable) {
      el.style.cursor = 'pointer';
      el.addEventListener('click', () => pickWallForReconstruct(wall));
    }
    if (isPunchable) {
      // Render each tile as a separate hoverable/clickable segment
      for (let t = 0; t < wall.length; t++) {
        const tileEl = document.createElement('div');
        tileEl.className = cls + ` wall-tile-punch ${wall.orientation}-tile`;
        Object.assign(tileEl.style, wallTileVisualPos(wall, t));
        tileEl.style.cursor = 'crosshair';
        tileEl.style.zIndex = '12';
        tileEl.title = wall.length === 1 ? 'Destroy wall' : (
          t === 0 ? 'Remove start tile' :
          t === wall.length - 1 ? 'Remove end tile' :
          'Punch gap through middle'
        );
        tileEl.addEventListener('click', (e) => {
          e.stopPropagation();
          pickTileForPunch(wall, t);
        });
        layer.appendChild(tileEl);
      }
      // Don't append the full-wall el in punch mode — only tiles
      continue;
    }

    layer.appendChild(el);
  }
}

function pickWallForRedeploy(wall) {
  if (uiMode !== 'wallPick') return;
  const pi = gameState.activePlayer;
  const cardIdx = gameState._redeployCardIdx;
  const cardId = gameState._redeployCardId || 'A4';

  // Lift the wall
  const len = wall.length;
  const dur = wall.durable || false;
  gameState.walls = gameState.walls.filter(w => w.id !== wall.id);
  gameState.players[pi] = { ...gameState.players[pi],
    wallsInPlay: Math.max(0, gameState.players[pi].wallsInPlay - 1) };

  // Discard the card
  discardCard(pi, cardIdx);
  gameState._redeployCardIdx = null;
  gameState._redeployCardId = null;

  // Enter wall placement — countCardPlayed will fire via onWallPlaced
  selectedCard = { id: cardId, idx:-1, length:len, isPhantom:false, isDurable:dur, _redeployed:true };
  uiMode = 'wall';
  addLog(pi, 'card', (cardId === 'AR3' ? 'Blueprint Shift' : 'Redeploy') + ': wall lifted — placing it again');
  renderAll();
  showStatus((cardId === 'AR3' ? 'Blueprint Shift' : 'Redeploy') + ': wall lifted — now place it in a new position', 'active');
}

function pickWallForRedirect(wall) {
  if (uiMode !== 'wallRedirect') return;
  const pi  = gameState.activePlayer;
  const opp = 1 - pi;
  const cardIdx = gameState._redirectCardIdx;

  // Lift the opponent wall — it keeps counting toward OPPONENT's wall count
  // (the wall is now in transit, owned by opponent but placed by player)
  const len = wall.length;
  gameState.walls = gameState.walls.filter(w => w.id !== wall.id);
  // NOTE: wallsInPlay NOT decremented — wall still counts as opponent's
  // It will be re-added to the board owned by opponent via executePlaceWall below

  discardCard(pi, cardIdx);
  gameState._redirectCardIdx = null;

  addLog(pi, 'card', 'Redirect: lifted opponent wall (' + len + '-tile) — placing it');
  // Enter wall placement — wall placed as OPPONENT's piece (not player's)
  // We store the opponent ownership in selectedCard for executePlaceWall to use
  selectedCard = { id:'T3', idx:-1, length:len, isPhantom:false, isDurable:false, _redirectOwner:opp };
  uiMode = 'wall';
  renderAll();
  showStatus("Redirect: place the opponent's wall in a new location", 'active');
}

function pickWallForSeal(wall) {
  if (uiMode !== 'wallSeal') return;
  const pi = gameState.activePlayer;
  const cardIdx = gameState._sealCardIdx;
  gameState.walls = gameState.walls.map(w =>
    w.id === wall.id ? { ...w, permanent: true, immune: true } : w
  );
  discardCard(pi, cardIdx);
  gameState._sealCardIdx = null;
  selectedCard = null;
  countCardPlayed(pi);
  uiMode = 'idle';
  addLog(pi, 'card', 'Seal: wall permanently sealed');
  if (isTurnDone()) gameState.phase = 'end_turn';
  renderAll();
  showStatus('Wall permanently sealed!', 'success');
}

function pickTileForPunch(wall, tileIndex) {
  if (uiMode !== 'wallPunch') return;
  const pi      = gameState.activePlayer;
  const cardIdx = gameState._punchCardIdx;
  const len     = wall.length;

  if (len <= 1) {
    // Single-tile wall: destroy it entirely
    gameState.walls = gameState.walls.filter(w => w.id !== wall.id);
    gameState.players[wall.owner] = {
      ...gameState.players[wall.owner],
      wallsInPlay: Math.max(0, gameState.players[wall.owner].wallsInPlay - 1)
    };
    addLog(pi, 'card', 'Punch Through: wall destroyed');
    showStatus('Wall destroyed!', 'success');

  } else if (tileIndex === 0) {
    // Remove the first tile: advance anchor by 1, shorten by 1
    const newAnchor = wall.orientation === 'H'
      ? {row: wall.anchor.row, col: wall.anchor.col + 1}
      : {row: wall.anchor.row + 1, col: wall.anchor.col};
    gameState.walls = gameState.walls.map(w =>
      w.id === wall.id ? {...w, anchor: newAnchor, length: len - 1} : w
    );
    addLog(pi, 'card', 'Punch Through: removed start tile');
    showStatus('Gap created at wall start!', 'success');

  } else if (tileIndex === len - 1) {
    // Remove the last tile: just shorten
    gameState.walls = gameState.walls.map(w =>
      w.id === wall.id ? {...w, length: len - 1} : w
    );
    addLog(pi, 'card', 'Punch Through: removed end tile');
    showStatus('Gap created at wall end!', 'success');

  } else {
    // Remove a middle tile: split into two fragments
    // Left fragment: from tile 0 to tileIndex-1
    const leftLen = tileIndex;
    const rightLen = len - tileIndex - 1;
    const rightAnchor = wall.orientation === 'H'
      ? {row: wall.anchor.row, col: wall.anchor.col + tileIndex + 1}
      : {row: wall.anchor.row + tileIndex + 1, col: wall.anchor.col};

    // Replace original wall with left fragment
    gameState.walls = gameState.walls.map(w =>
      w.id === wall.id ? {...w, length: leftLen} : w
    );
    // Add right fragment — no extra wallsInPlay cost (it's a fragment, not a new wall)
    const rightFrag = {
      ...wall,
      id: `w${gameState.nextWallId++}`,
      anchor: rightAnchor,
      length: rightLen,
      placedOnTurn: wall.placedOnTurn,
    };
    gameState.walls = [...gameState.walls, rightFrag];
    addLog(pi, 'card', 'Punch Through: gap punched through middle of wall');
    showStatus('Gap punched through wall!', 'success');
  }

  discardCard(pi, cardIdx);
  gameState._punchCardIdx = null;
  selectedCard = null;
  countCardPlayed(pi);
  uiMode = 'idle';
  if (isTurnDone()) gameState.phase = 'end_turn';
  renderAll();
}

function pickWallForReinforce(wall) {
  if (uiMode !== 'wallReinforce') return;
  const pi = gameState.activePlayer;
  const cardIdx = gameState._reinforceCardIdx;
  gameState.walls = gameState.walls.map(w =>
    w.id === wall.id ? { ...w, reinforced: true, immune: true, permanent: true } : w
  );
  discardCard(pi, cardIdx);
  gameState._reinforceCardIdx = null;
  selectedCard = null;
  countCardPlayed(pi);
  uiMode = 'idle';
  addLog(pi, 'card', 'Reinforce: wall permanently reinforced — immune to destruction and movement');
  if (isTurnDone()) gameState.phase = 'end_turn';
  renderAll();
  showStatus('Wall reinforced — immune to destruction and movement!', 'success');
}

function pickWallForReconstruct(wall) {
  if (uiMode !== 'wallReconstruct') return;
  const pi = gameState.activePlayer;
  const cardIdx = gameState._reconstructCardIdx;
  gameState.walls = gameState.walls.filter(w => w.id !== wall.id);
  gameState.players[pi] = {...gameState.players[pi], wallsInPlay: Math.max(0, gameState.players[pi].wallsInPlay - 1)};
  drawCards(pi, 1);
  discardCard(pi, cardIdx);
  gameState._reconstructCardIdx = null;
  selectedCard = null;
  countCardPlayed(pi);
  uiMode = 'idle';
  addLog(pi, 'card', 'Reconstruction: removed own wall, drew 1');
  if (isTurnDone()) gameState.phase = 'end_turn';
  renderAll();
  showStatus('Reconstruction: wall removed, drew 1!', 'success');
}

function pickWallForPunch(wall) {
  pickTileForPunch(wall, 0);
}

function wallTileVisualPos(wall, tileIndex) {
  // Returns visual pos with expanded click area (24px thick) centered on the wall line
  const {anchor, orientation} = wall;
  const step = CELL + GAP;
  const HIT = 24; // expanded hit area in px
  if (orientation === 'H') {
    return {
      left:     `${(anchor.col + tileIndex) * step}px`,
      top:      `${(anchor.row + 1) * step - GAP - (HIT - 6) / 2}px`,
      width:    `${step - GAP}px`,
      height:   `${HIT}px`,
      position: 'absolute',
    };
  } else {
    return {
      left:     `${(anchor.col + 1) * step - GAP - (HIT - 6) / 2}px`,
      top:      `${(anchor.row + tileIndex) * step}px`,
      width:    `${HIT}px`,
      height:   `${step - GAP}px`,
      position: 'absolute',
    };
  }
}

function wallVisualPos(wall) {
  const {anchor, orientation, length} = wall;
  const step = CELL+GAP;
  if (orientation==='H') {
    return {left:`${anchor.col*step}px`, top:`${(anchor.row+1)*step-GAP}px`, width:`${length*step-GAP}px`, height:'6px', position:'absolute'};
  } else {
    return {left:`${(anchor.col+1)*step-GAP}px`, top:`${anchor.row*step}px`, width:'6px', height:`${length*step-GAP}px`, position:'absolute'};
  }
}

// ── Edge-snapping wall placement ─────────────────────────────────────
// Each cell listens to mousemove. We compute where the cursor is within
// the cell (top/bottom third → H wall on that edge, left/right third →
// V wall on that edge) and snap the preview accordingly.

let previewEl = null;
let currentWallSpec = null; // {anchor, orientation} being previewed

function renderWallHotspots() {
  const overlay = document.getElementById('wall-overlay');
  if (!overlay) return;
  overlay.innerHTML = '';

  const length = selectedCard.length || 2;
  const isPhantom = selectedCard.isPhantom || false;
  const isDurable = selectedCard.isDurable || false;
  const step = CELL + GAP;

  // One transparent cell-sized div per cell to capture mouse events
  for (let r = 0; r < BOARD_SIZE; r++) {
    for (let c = 0; c < BOARD_SIZE; c++) {
      const el = document.createElement('div');
      el.style.cssText = `position:absolute;left:${c*step}px;top:${r*step}px;width:${CELL}px;height:${CELL}px;pointer-events:auto;cursor:crosshair;`;

      el.addEventListener('mousemove', (e) => {
        const rect = el.getBoundingClientRect();
        const lx = e.clientX - rect.left;   // 0–CELL
        const ly = e.clientY - rect.top;

        let orientation, anchor;
        const EDGE = CELL * 0.35; // inner 30% = vertical edge zone

        if (lx < EDGE) {
          // Left edge → V wall starting at (r, c-1) so the wall is between col c-1 and c
          orientation = 'V';
          anchor = {row: r, col: c - 1};
        } else if (lx > CELL - EDGE) {
          // Right edge → V wall between col c and c+1
          orientation = 'V';
          anchor = {row: r, col: c};
        } else if (ly < EDGE) {
          // Top edge → H wall between row r-1 and r
          orientation = 'H';
          anchor = {row: r - 1, col: c};
        } else {
          // Bottom edge → H wall between row r and r+1
          orientation = 'H';
          anchor = {row: r, col: c};
        }

        // Bounds check anchor
        if (!wallInBounds(anchor, orientation, length)) {
          // Try flipping anchor to keep within bounds
          if (orientation === 'H') anchor = {row: Math.max(0, Math.min(BOARD_SIZE-2, anchor.row)), col: Math.max(0, Math.min(BOARD_SIZE-length, anchor.col))};
          else anchor = {row: Math.max(0, Math.min(BOARD_SIZE-length, anchor.row)), col: Math.max(0, Math.min(BOARD_SIZE-2, anchor.col))};
          if (!wallInBounds(anchor, orientation, length)) return;
        }

        const specKey = `${orientation},${anchor.row},${anchor.col}`;
        const prevKey = currentWallSpec ? `${currentWallSpec.orientation},${currentWallSpec.anchor.row},${currentWallSpec.anchor.col}` : null;
        if (specKey !== prevKey) {
          currentWallSpec = {anchor, orientation, length, isPhantom, isDurable};
          showWallPreview(anchor, orientation, length, isPhantom);
        }
      });

      el.addEventListener('mouseleave', () => {
        // Only hide if we leave the whole board area, not just a cell
        // We let the next cell's mousemove re-draw; clear on board leave
      });

      el.addEventListener('click', () => {
        if (!currentWallSpec) return;
        const {anchor, orientation, length, isPhantom, isDurable} = currentWallSpec;
        handleWallClick(anchor, orientation, length, isPhantom, isDurable);
      });

      overlay.appendChild(el);
    }
  }

  // Hide preview when mouse leaves the whole board
  overlay.addEventListener('mouseleave', () => {
    hideWallPreview();
    currentWallSpec = null;
  });
}

function showWallPreview(anchor, orientation, length, isPhantom) {
  hideWallPreview();
  const layer = document.getElementById('wall-layer');
  if (!layer) return;
  const legal = isPhantom || isWallLegal(anchor, orientation, length, gameState.walls,
    gameState.players[0].position, gameState.players[1].position, isPhantom);
  previewEl = document.createElement('div');
  previewEl.className = `wall-preview-segment${legal ? '' : ' invalid'}`;
  Object.assign(previewEl.style, wallVisualPos({anchor, orientation, length}));
  layer.appendChild(previewEl);
}

function hideWallPreview() {
  if (previewEl) { previewEl.remove(); previewEl = null; }
}

function updateTurnBanner() {
  const banner = document.getElementById('turn-banner');
  const pi = gameState.activePlayer;
  const phase = gameState.phase;
  const champion = gameState.players[pi].champion.name;
  const isAI = pi === AI_PLAYER;
  const phaseLabel = {draw:'DRAW', action: isAI ? 'AI THINKING' : 'ACTION', end_turn:'END', ended:'GAME OVER'}[phase] || phase;
  if (banner) {
    banner.textContent = `${isAI?'AI':'YOU'} — ${champion.toUpperCase()} — ${phaseLabel}`;
    banner.className = `turn-banner p${pi}`;
  }
  const headerTurn = document.getElementById('header-turn');
  if (headerTurn) headerTurn.textContent = `TURN ${gameState.turnNumber}`;
  const headerPhase = document.getElementById('header-phase');
  if (headerPhase) {
    headerPhase.innerHTML = `<span class="phase-dot"></span>${phaseLabel}`;
    headerPhase.className = `phase-display phase-${phase}`;
  }
}

function renderLog() {
  const logEl = document.getElementById('game-log');
  if (!logEl) return;
  logEl.innerHTML = gameState.log.slice(-60).map(e => {
    const isAI = e.player === AI_PLAYER;
    const tag = e.type==='system' ? `<span class="sys-tag">SYS</span>` : `<span class="${isAI?'p1-tag':'p0-tag'}">${isAI?'AI ':'YOU'}</span>`;
    return `<div class="log-entry"><span class="turn-num">[T${e.turn}]</span>${tag} ${e.message}</div>`;
  }).join('');
  logEl.scrollTop = logEl.scrollHeight;
}

function showDirectionPicker(dirs, onChoose) {
  const existing = document.getElementById('direction-picker');
  if (existing) existing.remove();

  const overlay = document.createElement('div');
  overlay.id = 'direction-picker';
  overlay.style.cssText = `
    position:fixed; top:0; left:0; width:100%; height:100%;
    background:rgba(0,0,0,0.75); z-index:200;
    display:flex; align-items:center; justify-content:center;
    font-family:'JetBrains Mono',monospace;
  `;

  const panel = document.createElement('div');
  panel.style.cssText = `
    background:#1a1a2a; border:1px solid #3a2a5a;
    border-radius:10px; padding:24px 28px;
    display:flex; flex-direction:column; align-items:center; gap:16px;
    box-shadow:0 0 30px rgba(100,60,180,0.3);
  `;

  const header = document.createElement('div');
  header.innerHTML = `<span style="color:#a78bfa;font-size:10px;letter-spacing:0.18em;text-transform:uppercase">Compel</span><br>
    <span style="color:#d0c8e0;font-size:13px;margin-top:4px;display:block">Push opponent which direction?</span>`;
  panel.appendChild(header);

  // D-pad grid: [_, UP, _] [LEFT, _, RIGHT] [_, DOWN, _]
  const grid = document.createElement('div');
  grid.style.cssText = 'display:grid;grid-template-columns:56px 56px 56px;grid-template-rows:56px 56px 56px;gap:6px;';

  const dpadMap = [
    [null, 'UP ↑', null],
    ['LEFT ←', null, 'RIGHT →'],
    [null, 'DOWN ↓', null],
  ];

  dpadMap.forEach(row => row.forEach(label => {
    const cell = document.createElement('div');
    cell.style.cssText = 'width:56px;height:56px;display:flex;align-items:center;justify-content:center;';
    if (label) {
      const dir = dirs.find(d => d.label === label);
      const btn = document.createElement('button');
      const shortLabel = label.slice(-1); // just the arrow character
      btn.textContent = shortLabel;
      btn.disabled = !dir;
      btn.style.cssText = `
        width:100%;height:100%;font-size:22px;border-radius:8px;cursor:${dir?'pointer':'default'};
        border:1px solid ${dir?'#5a3a8a':'#2a2a3a'};
        background:${dir?'#2a1a4a':'#161620'}; color:${dir?'#c0a8f0':'#383850'};
        transition:background 0.12s,box-shadow 0.12s;
        font-family:inherit;
      `;
      if (dir) {
        btn.onmouseenter = () => { btn.style.background='#3d2070'; btn.style.boxShadow='0 0 12px rgba(160,100,255,0.4)'; };
        btn.onmouseleave = () => { btn.style.background='#2a1a4a'; btn.style.boxShadow=''; };
        btn.onclick = () => { overlay.remove(); onChoose(dir); };
      }
      cell.appendChild(btn);
    }
    grid.appendChild(cell);
  }));

  panel.appendChild(grid);

  const cancel = document.createElement('button');
  cancel.textContent = 'CANCEL';
  cancel.style.cssText = `
    margin-top:4px;padding:6px 24px;font-size:10px;letter-spacing:0.14em;
    background:transparent;border:1px solid #3a2a5a;color:#6a5a8a;
    border-radius:4px;cursor:pointer;font-family:inherit;text-transform:uppercase;
  `;
  cancel.onclick = () => overlay.remove();
  panel.appendChild(cancel);

  overlay.appendChild(panel);
  document.body.appendChild(overlay);
}

function showStatus(msg, type='') {
  const el = document.getElementById('mode-indicator');
  if (el) { el.textContent = msg; el.className = `mode-indicator${type?' '+type:''}`; }
}

// ── Victory ─────────────────────────────────────────────────────────
// ── Game record builder ──────────────────────────────────────────────
function buildGameRecord(winner) {
  const p0 = gameState.players[0], p1 = gameState.players[1];
  const log = gameState.log;

  // Per-player action counts
  function countActions(pi) {
    const moves  = log.filter(e => e.player===pi && e.type==='move').length;
    const walls  = log.filter(e => e.player===pi && e.type==='wall').length;
    const cards  = log.filter(e => e.player===pi && e.type==='card').length;
    const cardsPlayed = log.filter(e => e.player===pi && e.type==='card')
      .map(e => { const m = e.message.match(/Played[^:]*:\s*(.+?)(?:\s*—|$)/); return m?m[1].trim():null; })
      .filter(Boolean);
    return { moves, walls, cards, cardsPlayed };
  }

  const p0stats = countActions(0);
  const p1stats = countActions(1);

  return {
    id: Date.now(),
    timestamp: new Date().toISOString(),
    difficulty: aiDifficulty,
    turns: gameState.turnNumber,
    winner: winner === 0 ? 'player' : 'ai',
    player: {
      championId:   p0.champion.id,
      championName: p0.champion.name,
      faction:      p0.champion.faction,
      moves:        p0stats.moves,
      wallsPlaced:  p0stats.walls,
      cardsPlayed:  p0stats.cards,
      cardNames:    p0stats.cardsPlayed,
      finalRow:     p0.position.row,
    },
    ai: {
      championId:   p1.champion.id,
      championName: p1.champion.name,
      faction:      p1.champion.faction,
      moves:        p1stats.moves,
      wallsPlaced:  p1stats.walls,
      cardsPlayed:  p1stats.cards,
      cardNames:    p1stats.cardsPlayed,
      finalRow:     p1.position.row,
    },
    totalWalls: gameState.walls.filter(w => !w.isPhantom).length,
  };
}

async function saveGameRecord(record) {
  try {
    let records = [];
    const existing = await storageGet('corridors:games');
    if (existing) records = JSON.parse(existing.value);
    records.push(record);
    if (records.length > 500) records = records.slice(-500);
    await storageSet('corridors:games', JSON.stringify(records));
    console.log('[CORRIDORS] Game saved. Total:', records.length);
  } catch(e) {
    console.warn('[CORRIDORS] Save failed:', e);
  }
}

function showVictory(winner) {
  const record = buildGameRecord(winner);
  saveGameRecord(record); // async, fire-and-forget

  const overlay = document.getElementById('victory-overlay');
  if (!overlay) return;
  overlay.style.display = 'flex';

  const title    = document.getElementById('victory-title');
  const subtitle = document.getElementById('victory-subtitle');
  const champion = gameState.players[winner].champion.name;

  if (title) {
    title.textContent  = winner === AI_PLAYER ? 'AI WINS' : 'YOU WIN';
    title.style.color  = winner === 0 ? 'var(--p0)' : 'var(--p1)';
  }
  if (subtitle) subtitle.textContent = `${champion} reached the goal line — Turn ${gameState.turnNumber}`;

  const vt = document.getElementById('v-turns');
  if (vt) vt.textContent = gameState.turnNumber;
  const vw = document.getElementById('v-walls');
  if (vw) vw.textContent = gameState.walls.filter(w => !w.isPhantom).length;

  // ── Post-game summary panel ──────────────────────────────────────
  const existing = document.getElementById('postgame-summary');
  if (existing) existing.remove();

  const p0 = gameState.players[0], p1 = gameState.players[1];
  const loser = 1 - winner;

  const summaryHTML = `
  <div id="postgame-summary" style="
    margin-top:24px; width:520px; max-width:90vw;
    border:1px solid var(--border); background:var(--surface);
  ">
    <div style="display:grid;grid-template-columns:1fr 1fr;border-bottom:1px solid var(--border);">
      <div style="padding:12px 16px;border-right:1px solid var(--border);">
        <div style="font-size:9px;letter-spacing:.15em;color:var(--text-dim);margin-bottom:6px;text-transform:uppercase;">
          ${winner===0?'▲ WINNER':'▼ LOSER'} · YOU · ${p0.champion.faction}
        </div>
        <div style="font-family:'Teko',sans-serif;font-size:22px;color:var(--p0);letter-spacing:.05em;">${p0.champion.name}</div>
        <div style="margin-top:10px;display:grid;grid-template-columns:1fr 1fr 1fr;gap:6px;">
          ${statBox('MOVES', record.player.moves)}
          ${statBox('WALLS', record.player.wallsPlaced)}
          ${statBox('CARDS', record.player.cardsPlayed)}
        </div>
      </div>
      <div style="padding:12px 16px;">
        <div style="font-size:9px;letter-spacing:.15em;color:var(--text-dim);margin-bottom:6px;text-transform:uppercase;">
          ${winner===1?'▲ WINNER':'▼ LOSER'} · AI (${aiDifficulty.toUpperCase()}) · ${p1.champion.faction}
        </div>
        <div style="font-family:'Teko',sans-serif;font-size:22px;color:var(--p1);letter-spacing:.05em;">${p1.champion.name}</div>
        <div style="margin-top:10px;display:grid;grid-template-columns:1fr 1fr 1fr;gap:6px;">
          ${statBox('MOVES', record.ai.moves)}
          ${statBox('WALLS', record.ai.wallsPlaced)}
          ${statBox('CARDS', record.ai.cardsPlayed)}
        </div>
      </div>
    </div>
    <div style="padding:10px 16px;display:flex;gap:24px;align-items:center;">
      <div style="font-size:9px;color:var(--text-dim);letter-spacing:.1em;">
        <span style="color:var(--text-bright);">${gameState.turnNumber}</span> TURNS
        &nbsp;·&nbsp;
        <span style="color:var(--text-bright);">${record.totalWalls}</span> WALLS ON BOARD
        &nbsp;·&nbsp;
        <span style="color:var(--text-bright);">${aiDifficulty.toUpperCase()}</span> DIFFICULTY
      </div>
    </div>
  </div>`;

  const victoryBox = overlay.querySelector('.victory-box') || overlay;
  victoryBox.insertAdjacentHTML('beforeend', summaryHTML);
}

function statBox(label, value) {
  return '<div style="background:var(--surface2);border:1px solid var(--border);padding:5px 7px;text-align:center;">'
    + '<div style="font-size:8px;color:var(--text-dim);letter-spacing:.1em;">' + label + '</div>'
    + '<div style="font-family:Teko,sans-serif;font-size:20px;color:var(--text-bright);">' + value + '</div>'
    + '</div>';
}

function resetGame() {
  const overlay = document.getElementById('victory-overlay');
  if (overlay) overlay.style.display = 'none';
  showChampionSelect();
}

// ── Utilities ────────────────────────────────────────────────────────
function setText(id, val) {
  const el = document.getElementById(id);
  if (el) el.textContent = val;
}

// ── Debug overlay ────────────────────────────────────────────────────
document.addEventListener('keydown', e => {
  if (e.key.toLowerCase()==='d' && (e.ctrlKey||e.metaKey)) {
    e.preventDefault();
    debugVisible = !debugVisible;
    const overlay = document.getElementById('debug-overlay');
    if (overlay) overlay.className = debugVisible?'visible':'';
    if (debugVisible) updateDebug();
  }
});

function updateDebug() {
  const el = document.getElementById('debug-content');
  if (!el||!debugVisible) return;
  el.textContent = JSON.stringify({
    turn: gameState.turnNumber,
    phase: gameState.phase,
    activePlayer: gameState.activePlayer,
    hasMoved,
    hasPlayedCard,
    uiMode,
    selectedCard,
    walls: gameState.walls.map(w=>({id:w.id,owner:w.owner,anchor:w.anchor,orient:w.orientation,phantom:w.isPhantom})),
    p0: {pos:gameState.players[0].position, hand:gameState.players[0].hand.map(c=>c.name), walls:gameState.players[0].wallsInPlay},
    p1: {pos:gameState.players[1].position, hand:gameState.players[1].hand.map(c=>c.name), walls:gameState.players[1].wallsInPlay},
  }, null, 2);
}

// ── Init ─────────────────────────────────────────────────────────────
document.addEventListener("DOMContentLoaded", () => {
  // Check URL for invite code before showing champion select
  const urlParams = new URLSearchParams(window.location.search);
  const inviteCode = urlParams.get('join');
  if (inviteCode) {
    // Clean URL without reloading
    window.history.replaceState({}, '', window.location.pathname);
    showMultiplayerLobby('join', inviteCode);
  } else {
    showChampionSelect();
  }
});

// ═══════════════════════════════════════════════════════════════════
// CORRIDORS — ASYNC MULTIPLAYER MODULE
// ─────────────────────────────────────────────────────────────────
// Architecture:
//   • Supabase (postgres + realtime) as backend — free tier
//   • Anonymous auth via Supabase (persistent userId per browser)
//   • Each "game" is a row in the `mp_games` table
//   • gameState JSON stored in `state` column, updated each turn
//   • Realtime subscription triggers UI refresh on opponent move
//   • Each player only sees their OWN hand; opponent hand is hidden
//   • mp_localPlayerIndex: 0 or 1 — which seat this browser owns
// ═══════════════════════════════════════════════════════════════════

// ── Supabase Config ──────────────────────────────────────────────────
// INSTRUCTIONS: Replace with your own Supabase project credentials.
// 1. Go to https://supabase.com and create a free project
// 2. Go to Project Settings → API and copy your URL and anon key
// 3. Run the SQL in SUPABASE_SCHEMA below in the SQL Editor
// 4. Enable Realtime for the mp_games table in Database → Replication
const SUPABASE_URL  = 'https://fdkiadwkgsrzhlhswoxq.supabase.co';
const SUPABASE_ANON = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZka2lhZHdrZ3NyemhsaHN3b3hxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzIyNTA2MTQsImV4cCI6MjA4NzgyNjYxNH0.5f8TcvQjdIvwfeexjDTF7MRzqoyo_5NGtGblpjTxTsQ';

// ── SQL Schema (run once in Supabase SQL Editor) ─────────────────────
/*
SUPABASE_SCHEMA = `
  -- Enable UUID extension
  create extension if not exists "pgcrypto";

  -- Main games table
  create table if not exists mp_games (
    id           text primary key default encode(gen_random_bytes(5), 'hex'),
    created_at   timestamptz default now(),
    updated_at   timestamptz default now(),
    status       text not null default 'waiting',   -- waiting | active | finished
    host_id      text not null,
    guest_id     text,
    host_name    text not null default 'Player',
    guest_name   text,
    host_champ   text not null,
    guest_champ  text,
    state        jsonb,           -- serialised gameState
    active_seat  int default 0,  -- 0 = host's turn, 1 = guest's turn
    winner_seat  int,            -- null | 0 | 1
    host_hand    jsonb,          -- private: only host reads this
    guest_hand   jsonb           -- private: only guest reads this
  );

  -- Row-level security: everyone can read; only owner can write their hand columns
  alter table mp_games enable row level security;
  create policy "public read" on mp_games for select using (true);
  create policy "host insert" on mp_games for insert with check (true);
  create policy "players update" on mp_games for update using (true);

  -- Updated_at trigger
  create or replace function set_updated_at()
  returns trigger language plpgsql as \$\$
  begin new.updated_at = now(); return new; end; \$\$;

  drop trigger if exists mp_games_updated_at on mp_games;
  create trigger mp_games_updated_at before update on mp_games
    for each row execute function set_updated_at();
`;
*/

// ── Module state ─────────────────────────────────────────────────────
let _sb = null;         // Supabase client
let _sbReady = false;
let _userId = null;     // anonymous user id stored in localStorage
let _userName = null;   // display name
let mp_gameId = null;   // active multiplayer game id
let mp_localSeat = null; // 0 or 1 — which seat this browser is
let mp_subscription = null; // realtime channel
let mp_pendingJoin = null;  // invite code from URL
let mp_lobbyInterval = null; // polling interval for lobby
let mp_isMultiplayer = false; // true when in a multiplayer game
let mp_opponentName = null;

// ── Supabase initialisation ──────────────────────────────────────────
function mpInit() {
  if (_sb) return _sb;
  if (!window.supabase) {
    console.warn('[MP] Supabase SDK not loaded');
    return null;
  }
  if (SUPABASE_URL === 'YOUR_SUPABASE_URL') {
    console.warn('[MP] Supabase credentials not configured');
    return null;
  }
  try {
    _sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON);
    _sbReady = true;
    // Generate/restore anonymous userId
    _userId = localStorage.getItem('corridors:userId');
    if (!_userId) {
      _userId = 'u_' + Math.random().toString(36).slice(2, 10) + Date.now().toString(36);
      localStorage.setItem('corridors:userId', _userId);
    }
    _userName = localStorage.getItem('corridors:userName') || '';
  } catch(e) {
    console.error('[MP] Init failed:', e);
    _sb = null;
  }
  return _sb;
}

function mpConfigured() {
  return SUPABASE_URL !== 'YOUR_SUPABASE_URL' && SUPABASE_ANON !== 'YOUR_SUPABASE_ANON_KEY';
}

// ── Multiplayer Lobby UI ─────────────────────────────────────────────
function showMultiplayerLobby(tab = 'home', prefillCode = null) {
  // Remove any existing
  const existing = document.getElementById('mp-overlay');
  if (existing) existing.remove();

  const overlay = document.createElement('div');
  overlay.id = 'mp-overlay';
  overlay.className = 'mp-overlay';

  overlay.innerHTML = `
    <div class="mp-logo">CORRIDORS</div>
    <div style="font-size:11px;letter-spacing:.2em;color:var(--text-dim);text-transform:uppercase;margin-bottom:28px;">Async PvP Mode</div>

    <div class="mp-mode-tabs">
      <button class="mp-tab ${tab==='home'?'active':''}" onclick="mpShowTab('home')">MY GAMES</button>
      <button class="mp-tab ${tab==='create'?'active':''}" onclick="mpShowTab('create')">CREATE GAME</button>
      <button class="mp-tab ${tab==='join'?'active':''}" onclick="mpShowTab('join')">JOIN GAME</button>
    </div>

    <div class="mp-panel" id="mp-tab-content">
      <!-- Filled by mpShowTab -->
    </div>

    <div style="margin-top:20px;">
      <button class="mp-btn secondary" style="width:auto;padding:8px 24px;" onclick="closeMpLobby()">← BACK TO VS AI</button>
    </div>
  `;

  document.body.appendChild(overlay);

  // Prefill join code from URL invite
  if (prefillCode) {
    setTimeout(() => {
      mpShowTab('join');
      const inp = document.getElementById('mp-join-code');
      if (inp) inp.value = prefillCode;
    }, 50);
  } else {
    mpShowTab(tab);
  }
}

function closeMpLobby() {
  const overlay = document.getElementById('mp-overlay');
  if (overlay) overlay.remove();
  clearInterval(mp_lobbyInterval);
}

function mpShowTab(tab) {
  // Update tab buttons
  document.querySelectorAll('.mp-tab').forEach(btn => {
    btn.className = 'mp-tab' + (btn.textContent.trim().toLowerCase().startsWith(tab) || 
      (tab==='home' && btn.textContent.includes('MY')) ||
      (tab==='create' && btn.textContent.includes('CREATE')) ||
      (tab==='join' && btn.textContent.includes('JOIN')) ? ' active' : '');
  });

  const content = document.getElementById('mp-tab-content');
  if (!content) return;

  // Stop any lobby polling
  clearInterval(mp_lobbyInterval);

  if (!mpConfigured()) {
    content.innerHTML = mpUnconfiguredPanel();
    return;
  }

  switch(tab) {
    case 'home':   mpRenderHomeTab(content); break;
    case 'create': mpRenderCreateTab(content); break;
    case 'join':   mpRenderJoinTab(content); break;
  }
}

function mpUnconfiguredPanel() {
  return `
    <div class="mp-section-label">Setup Required</div>
    <div class="mp-config-note">
      <strong>Async PvP requires Supabase credentials.</strong><br><br>
      1. Create a free project at <strong>supabase.com</strong><br>
      2. Go to <strong>Project Settings → API</strong> and copy your URL and anon key<br>
      3. Open this file and replace the two constants near the top of the multiplayer module:<br><br>
      <code>const SUPABASE_URL  = 'YOUR_SUPABASE_URL';</code><br>
      <code>const SUPABASE_ANON = 'YOUR_SUPABASE_ANON_KEY';</code><br><br>
      4. In the Supabase <strong>SQL Editor</strong>, run the schema found in the <code>SUPABASE_SCHEMA</code> comment block in the source.<br>
      5. In <strong>Database → Replication</strong>, enable Realtime for the <code>mp_games</code> table.<br><br>
      That's it — no server needed. The free tier supports unlimited async games.
    </div>
  `;
}

function mpNameInput(forTab) {
  const saved = localStorage.getItem('corridors:userName') || '';
  return `
    <div class="mp-section-label" style="margin-bottom:6px;">Your Display Name</div>
    <input class="mp-input" id="mp-name-input" placeholder="Enter your name…" value="${saved}" maxlength="24">
  `;
}

// ── Home Tab (My Games) ──────────────────────────────────────────────
async function mpRenderHomeTab(content) {
  content.innerHTML = `
    ${mpNameInput()}
    <hr class="mp-divider">
    <div class="mp-section-label">Active Games</div>
    <div class="mp-game-list" id="mp-game-list">
      <div style="text-align:center;padding:24px;color:var(--text-dim);font-size:11px;letter-spacing:.12em;">
        <div class="mp-spinner" style="margin:0 auto 10px;"></div>
        LOADING…
      </div>
    </div>
  `;
  await mpLoadMyGames();
  // Poll every 8s for new turns
  mp_lobbyInterval = setInterval(mpLoadMyGames, 8000);
}

async function mpLoadMyGames() {
  const sb = mpInit();
  if (!sb) return;
  try {
    const { data, error } = await sb
      .from('mp_games')
      .select('id,status,host_id,guest_id,host_name,guest_name,host_champ,guest_champ,active_seat,winner_seat,updated_at')
      .or(`host_id.eq.${_userId},guest_id.eq.${_userId}`)
      .order('updated_at', { ascending: false })
      .limit(20);

    const list = document.getElementById('mp-game-list');
    if (!list) return;
    if (error) { list.innerHTML = `<div class="mp-status error">Error: ${error.message}</div>`; return; }
    if (!data || data.length === 0) {
      list.innerHTML = `<div style="text-align:center;padding:24px;color:var(--text-dim);font-size:11px;letter-spacing:.12em;">No games yet — create or join one!</div>`;
      return;
    }
    list.innerHTML = data.map(g => mpGameItem(g)).join('');
  } catch(e) {
    console.error('[MP] loadMyGames error:', e);
  }
}

function mpGameItem(g) {
  const iAmHost = g.host_id === _userId;
  const mySeat = iAmHost ? 0 : 1;
  const myName = iAmHost ? g.host_name : (g.guest_name || '?');
  const oppName = iAmHost ? (g.guest_name || '?') : g.host_name;
  const myChamp = iAmHost ? g.host_champ : (g.guest_champ || '?');

  let badge = '', badgeClass = '';
  if (g.status === 'waiting') {
    badge = '⏳ WAITING FOR OPPONENT'; badgeClass = 'waiting';
  } else if (g.status === 'finished') {
    const won = g.winner_seat === mySeat;
    badge = won ? '🏆 YOU WON' : '💀 YOU LOST'; badgeClass = 'finished';
  } else {
    const myTurn = g.active_seat === mySeat;
    badge = myTurn ? '⚡ YOUR TURN' : '⏱ THEIR TURN';
    badgeClass = myTurn ? 'your-turn' : 'their-turn';
  }

  const d = new Date(g.updated_at);
  const timeAgo = mpTimeAgo(d);

  return `
    <div class="mp-game-item" onclick="mpResumeGame('${g.id}')">
      <div class="mp-game-item-info">
        <div class="mp-game-item-name">${myName} vs ${oppName}</div>
        <div class="mp-game-item-meta">${myChamp.toUpperCase()} · Game #${g.id} · ${timeAgo}</div>
      </div>
      <div class="mp-game-item-badge ${badgeClass}">${badge}</div>
    </div>
  `;
}

function mpTimeAgo(d) {
  const sec = Math.floor((Date.now() - d) / 1000);
  if (sec < 60) return 'just now';
  if (sec < 3600) return `${Math.floor(sec/60)}m ago`;
  if (sec < 86400) return `${Math.floor(sec/3600)}h ago`;
  return `${Math.floor(sec/86400)}d ago`;
}

// ── Create Tab ───────────────────────────────────────────────────────
function mpRenderCreateTab(content) {
  const champCards = Object.values(CHAMPIONS).map(c => `
    <div class="cs-card" id="mpc-${c.id}" onclick="mpSelectChamp('${c.id}')" style="padding:12px 14px;">
      <div class="cs-champ-name" style="font-size:20px;">${c.name}</div>
      <div class="cs-champ-title" style="font-size:10px;">${c.title}</div>
      <div class="cs-faction" style="font-size:9px;margin-top:3px;">${c.faction}</div>
    </div>
  `).join('');

  content.innerHTML = `
    ${mpNameInput('create')}
    <hr class="mp-divider">
    <div class="mp-section-label">Choose Your Champion</div>
    <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:20px;" id="mpc-grid">
      ${champCards}
    </div>
    <button class="mp-btn" id="mp-create-btn" onclick="mpCreateGame()" disabled>
      SELECT A CHAMPION TO CREATE GAME →
    </button>
    <div id="mp-create-status"></div>
  `;
}

let mp_selectedChamp = null;
function mpSelectChamp(id) {
  mp_selectedChamp = id;
  document.querySelectorAll('[id^="mpc-"]').forEach(el => el.classList.remove('selected'));
  const card = document.getElementById('mpc-' + id);
  if (card) card.classList.add('selected');
  const btn = document.getElementById('mp-create-btn');
  if (btn) {
    btn.textContent = `CREATE GAME AS ${CHAMPIONS[id].name.toUpperCase()} →`;
    btn.disabled = false;
  }
}

async function mpCreateGame() {
  const sb = mpInit();
  if (!sb) return;
  const nameEl = document.getElementById('mp-name-input');
  const name = (nameEl?.value?.trim() || 'Player').slice(0, 24);
  localStorage.setItem('corridors:userName', name);
  _userName = name;

  if (!mp_selectedChamp) return;

  const btn = document.getElementById('mp-create-btn');
  if (btn) { btn.disabled = true; btn.textContent = 'CREATING…'; }

  try {
    const { data, error } = await sb.from('mp_games').insert({
      host_id:    _userId,
      host_name:  name,
      host_champ: mp_selectedChamp,
      status:     'waiting',
    }).select().single();

    if (error) throw error;

    const gameId = data.id;
    const inviteUrl = `${window.location.href.split('?')[0]}?join=${gameId}`;

    const statusEl = document.getElementById('mp-create-status');
    if (statusEl) statusEl.innerHTML = `
      <div class="mp-status info">
        <div><span class="mp-waiting-pulse"></span>Waiting for opponent to join…</div>
      </div>
      <div class="mp-section-label" style="margin-top:16px;">Share This Invite Link</div>
      <div class="mp-invite-box" onclick="mpCopyInvite('${inviteUrl}',this)" title="Click to copy">
        ${inviteUrl}
      </div>
      <button class="mp-btn" onclick="mpCopyInvite('${inviteUrl}',this)">📋 COPY INVITE LINK</button>
      <div style="margin-top:8px;font-size:10px;color:var(--text-dim);text-align:center;letter-spacing:.1em;">
        Or share code: <strong style="color:var(--amber)">${gameId}</strong>
      </div>
    `;

    // Poll for guest joining
    const pollId = setInterval(async () => {
      const { data: g } = await sb.from('mp_games').select('status,guest_id,guest_name,guest_champ').eq('id', gameId).single();
      if (g && g.status === 'active') {
        clearInterval(pollId);
        mp_opponentName = g.guest_name;
        mpStartHostGame(gameId, mp_selectedChamp, g.guest_champ, g.guest_name);
      }
    }, 3000);

    // Store poll so we can cancel on nav
    mp_lobbyInterval = pollId;

  } catch(e) {
    console.error('[MP] createGame error:', e);
    const statusEl = document.getElementById('mp-create-status');
    if (statusEl) statusEl.innerHTML = `<div class="mp-status error">Error: ${e.message}</div>`;
    if (btn) { btn.disabled = false; btn.textContent = 'TRY AGAIN'; }
  }
}

function mpCopyInvite(url, el) {
  navigator.clipboard.writeText(url).then(() => {
    if (el) { const orig = el.textContent; el.textContent = '✓ COPIED!'; setTimeout(() => el.textContent = orig, 2000); }
  }).catch(() => {
    prompt('Copy this link:', url);
  });
}

// ── Join Tab ─────────────────────────────────────────────────────────
function mpRenderJoinTab(content) {
  const champCards = Object.values(CHAMPIONS).map(c => `
    <div class="cs-card" id="mpj-${c.id}" onclick="mpSelectJoinChamp('${c.id}')" style="padding:12px 14px;">
      <div class="cs-champ-name" style="font-size:20px;">${c.name}</div>
      <div class="cs-champ-title" style="font-size:10px;">${c.title}</div>
      <div class="cs-faction" style="font-size:9px;margin-top:3px;">${c.faction}</div>
    </div>
  `).join('');

  content.innerHTML = `
    ${mpNameInput('join')}
    <hr class="mp-divider">
    <div class="mp-section-label">Game Code or Invite Link</div>
    <input class="mp-input" id="mp-join-code" placeholder="Enter game code (e.g. a1b2c)…" maxlength="100">
    <hr class="mp-divider">
    <div class="mp-section-label">Choose Your Champion</div>
    <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:20px;" id="mpj-grid">
      ${champCards}
    </div>
    <button class="mp-btn" id="mp-join-btn" onclick="mpJoinGame()" disabled>
      SELECT A CHAMPION TO JOIN →
    </button>
    <div id="mp-join-status"></div>
  `;
}

let mp_joinSelectedChamp = null;
function mpSelectJoinChamp(id) {
  mp_joinSelectedChamp = id;
  document.querySelectorAll('[id^="mpj-"]').forEach(el => el.classList.remove('selected'));
  const card = document.getElementById('mpj-' + id);
  if (card) card.classList.add('selected');
  const btn = document.getElementById('mp-join-btn');
  if (btn) {
    btn.textContent = `JOIN AS ${CHAMPIONS[id].name.toUpperCase()} →`;
    btn.disabled = false;
  }
}

async function mpJoinGame() {
  const sb = mpInit();
  if (!sb) return;
  const nameEl = document.getElementById('mp-name-input');
  const name = (nameEl?.value?.trim() || 'Player').slice(0, 24);
  localStorage.setItem('corridors:userName', name);
  _userName = name;

  let code = (document.getElementById('mp-join-code')?.value?.trim() || '');
  // Handle full URLs — extract just the game id
  const urlMatch = code.match(/[?&]join=([a-zA-Z0-9]+)/);
  if (urlMatch) code = urlMatch[1];
  code = code.replace(/\s/g, '').toLowerCase().slice(0, 20);

  if (!code) { mpSetStatus('mp-join-status', 'Enter a game code or invite link', 'error'); return; }
  if (!mp_joinSelectedChamp) { mpSetStatus('mp-join-status', 'Select a champion first', 'error'); return; }

  const btn = document.getElementById('mp-join-btn');
  if (btn) { btn.disabled = true; btn.textContent = 'JOINING…'; }

  try {
    // Fetch the game
    const { data: g, error: fetchErr } = await sb.from('mp_games').select('*').eq('id', code).single();
    if (fetchErr || !g) throw new Error('Game not found');
    if (g.status !== 'waiting') throw new Error('Game already started or finished');
    if (g.host_id === _userId) throw new Error("Can't join your own game");

    // Randomize who goes first
    const firstSeat = Math.random() < 0.5 ? 0 : 1;

    // Build initial game state (server side — but we do it client-side for simplicity)
    const hostChamp = g.host_champ;
    const guestChamp = mp_joinSelectedChamp;
    const initState = mpBuildInitialState(hostChamp, guestChamp, firstSeat);

    // Store hands separately (private to each player)
    const hostHand = initState.players[0].hand;
    const guestHand = initState.players[1].hand;
    // Scrub hands from shared state (security)
    const sharedState = mpScrubHands(initState);

    const { error: updateErr } = await sb.from('mp_games').update({
      guest_id:    _userId,
      guest_name:  name,
      guest_champ: guestChamp,
      status:      'active',
      active_seat: firstSeat,
      state:       sharedState,
      host_hand:   JSON.stringify(hostHand),
      guest_hand:  JSON.stringify(guestHand),
    }).eq('id', code);

    if (updateErr) throw updateErr;

    mp_opponentName = g.host_name;
    mpStartGuestGame(code, guestChamp, hostChamp, g.host_name, firstSeat, guestHand, initState);

  } catch(e) {
    console.error('[MP] joinGame error:', e);
    mpSetStatus('mp-join-status', e.message || 'Join failed', 'error');
    if (btn) { btn.disabled = false; btn.textContent = 'TRY AGAIN'; }
  }
}

function mpSetStatus(id, msg, type) {
  const el = document.getElementById(id);
  if (el) el.innerHTML = `<div class="mp-status ${type}">${msg}</div>`;
}

// ── Game initialisation helpers ──────────────────────────────────────
function mpBuildInitialState(hostChampId, guestChampId, firstSeat) {
  // Mirrors initGame() but doesn't touch global gameState or UI yet
  const hChamp = CHAMPIONS[hostChampId];
  const gChamp = CHAMPIONS[guestChampId];
  const state = {
    players: [
      createPlayer(0, hostChampId,  hChamp.faction),
      createPlayer(1, guestChampId, gChamp.faction),
    ],
    walls: [], decoyTokens: [], trapTokens: [],
    activePlayer: firstSeat, turnNumber: 1, phase: 'draw',
    winner: null, log: [], nextWallId: 1, nextTokenId: 1,
    firstDraw: [true, true],
    // Perform opening draws
  };
  // Draw opening hands for both players
  for (const pi of [0, 1]) {
    const p = state.players[pi];
    const count = p.champion.cardDraw;
    const drawn = p.deck.splice(0, count);
    state.players[pi].hand = drawn;
    state.players[pi].firstDraw = false;
  }
  state.firstDraw = [false, false];
  return state;
}

function mpScrubHands(state) {
  // Return a copy where hand arrays are empty (stored separately per player)
  return {
    ...state,
    players: state.players.map(p => ({ ...p, hand: [], deck: [] }))
  };
}

// ── Start game (host) ────────────────────────────────────────────────
async function mpStartHostGame(gameId, myChamp, oppChamp, oppName) {
  const sb = mpInit();
  if (!sb) return;

  // Load the current game state + our private hand
  const { data: g } = await sb.from('mp_games').select('*').eq('id', gameId).single();
  if (!g) return;

  closeMpLobby();
  const myHand = JSON.parse(g.host_hand || '[]');
  const sharedState = g.state;
  mpLaunchGame(gameId, 0, myChamp, oppChamp, oppName, myHand, sharedState);
}

// ── Start game (guest) ───────────────────────────────────────────────
function mpStartGuestGame(gameId, myChamp, oppChamp, oppName, firstSeat, myHand, fullState) {
  closeMpLobby();
  const sharedState = mpScrubHands(fullState);
  mpLaunchGame(gameId, 1, myChamp, oppChamp, oppName, myHand, sharedState);
}

// ── Resume an existing game ──────────────────────────────────────────
async function mpResumeGame(gameId) {
  const sb = mpInit();
  if (!sb) return;
  try {
    const { data: g } = await sb.from('mp_games').select('*').eq('id', gameId).single();
    if (!g) { alert('Game not found'); return; }

    const iAmHost = g.host_id === _userId;
    const mySeat = iAmHost ? 0 : 1;
    const myChamp = iAmHost ? g.host_champ : g.guest_champ;
    const oppChamp = iAmHost ? g.guest_champ : g.host_champ;
    const oppName = iAmHost ? (g.guest_name || '?') : g.host_name;
    const myHandRaw = iAmHost ? g.host_hand : g.guest_hand;
    const myHand = JSON.parse(myHandRaw || '[]');

    if (!g.state) { alert('Game state not available'); return; }

    closeMpLobby();
    mpLaunchGame(gameId, mySeat, myChamp, oppChamp, oppName, myHand, g.state);
  } catch(e) {
    console.error('[MP] resume error:', e);
    alert('Failed to load game: ' + e.message);
  }
}

// ── Core: Launch multiplayer game ────────────────────────────────────
function mpLaunchGame(gameId, localSeat, myChampId, oppChampId, oppName, myHand, sharedState) {
  mp_gameId = gameId;
  mp_localSeat = localSeat;
  mp_isMultiplayer = true;
  mp_opponentName = oppName;

  const oppSeat = 1 - localSeat;

  // Reconstruct full gameState from shared state + private hand
  // We need full CHAMPIONS/deck data; rebuild players from champion IDs
  const hId = localSeat === 0 ? myChampId : oppChampId;
  const gId = localSeat === 1 ? myChampId : oppChampId;

  // Restore state — merge shared state with our private hand
  gameState = {
    ...sharedState,
    players: sharedState.players.map((p, i) => {
      const isMe = i === localSeat;
      return {
        ...p,
        champion: { ...CHAMPIONS[i === 0 ? hId : gId] },
        hand: isMe ? myHand : [],
        // Restore deck from champion def (length only used for display)
        deck: isMe ? (sharedState._hostDeckLen !== undefined 
          ? Array(i===0 ? sharedState._hostDeckLen : sharedState._guestDeckLen).fill({name:'?'})
          : Array(10).fill({name:'?'}))
          : [],
      };
    }),
  };

  // Reset UI flags
  uiMode = 'idle';
  selectedCard = null;
  hasMoved = false;
  hasPlayedCard = false;
  cardsPlayedThisTurn = 0;

  // Override AI_PLAYER — in MP there's no AI; opponent is the other seat
  // We patch rendering: player 0 is always host, player 1 is always guest
  // localSeat 0 = you're player 0; localSeat 1 = you're player 1

  mpUpdatePanelLabels();
  renderAll();
  mpUpdateTurnState();

  // Subscribe to realtime updates
  mpSubscribe(gameId, localSeat, myHand.length, myChampId, oppChampId);

  addLog(localSeat, 'system', `Async PvP: You are ${CHAMPIONS[myChampId].name} (Seat ${localSeat}) vs ${oppName} (${CHAMPIONS[oppChampId].name})`);
  renderLog();

  showStatus(gameState.activePlayer === localSeat
    ? '⚡ YOUR TURN — make your move!'
    : `⏱ Waiting for ${oppName}…`, '');
}

function mpUpdatePanelLabels() {
  const p0Label = document.querySelector('#panel-p0 .panel-label');
  const p1Label = document.querySelector('#panel-p1 .panel-label');
  if (p0Label) p0Label.textContent = mp_localSeat === 0 ? 'YOU' : mp_opponentName?.toUpperCase() || 'OPPONENT';
  if (p1Label) p1Label.textContent = mp_localSeat === 1 ? 'YOU' : mp_opponentName?.toUpperCase() || 'OPPONENT';
}

function mpUpdateTurnState() {
  if (!mp_isMultiplayer) return;
  const isMyTurn = gameState.activePlayer === mp_localSeat;
  const oppName = mp_opponentName || 'Opponent';
  const myChamp = gameState.players[mp_localSeat]?.champion?.name || '';
  const oppChamp = gameState.players[1 - mp_localSeat]?.champion?.name || '';

  if (gameState.phase === 'ended' || gameState.winner !== null) {
    const iWon = gameState.winner === mp_localSeat;
    showStatus(iWon ? '🏆 YOU WIN!' : '💀 OPPONENT WINS', iWon ? 'success' : 'error');
    return;
  }

  if (isMyTurn) {
    showStatus(`⚡ YOUR TURN — ${myChamp}`, 'active');
  } else {
    showStatus(`⏱ Waiting for ${oppName} (${oppChamp})…`, '');
  }
}

// ── Realtime Subscription ────────────────────────────────────────────
function mpSubscribe(gameId, localSeat, myHandLen, myChampId, oppChampId) {
  if (!_sb) return;

  // Clean up any old subscription
  if (mp_subscription) {
    _sb.removeChannel(mp_subscription);
    mp_subscription = null;
  }

  mp_subscription = _sb
    .channel(`game:${gameId}`)
    .on('postgres_changes', {
      event: 'UPDATE',
      schema: 'public',
      table: 'mp_games',
      filter: `id=eq.${gameId}`,
    }, (payload) => {
      mpHandleRemoteUpdate(payload.new, localSeat, myChampId, oppChampId);
    })
    .subscribe();
}

async function mpHandleRemoteUpdate(row, localSeat, myChampId, oppChampId) {
  // Only process if it's now our turn (opponent just moved)
  if (row.active_seat === localSeat && row.status === 'active') {
    // Fetch our private hand
    const { data: g } = await _sb.from('mp_games').select('host_hand,guest_hand').eq('id', mp_gameId).single();
    const myHandRaw = localSeat === 0 ? g?.host_hand : g?.guest_hand;
    const myHand = JSON.parse(myHandRaw || '[]');

    // Merge updated state with our hand
    const shared = row.state;
    const hId = localSeat === 0 ? myChampId : oppChampId;
    const gId = localSeat === 1 ? myChampId : oppChampId;

    gameState = {
      ...shared,
      players: shared.players.map((p, i) => ({
        ...p,
        champion: { ...CHAMPIONS[i === 0 ? hId : gId] },
        hand: i === localSeat ? myHand : [],
        deck: [],
      })),
    };

    hasMoved = false;
    hasPlayedCard = false;
    cardsPlayedThisTurn = 0;
    uiMode = 'idle';
    selectedCard = null;

    mpUpdatePanelLabels();
    renderAll();
    mpUpdateTurnState();
    addLog(localSeat, 'system', `Opponent moved — your turn!`);
    renderLog();

    // Flash the banner
    const banner = document.getElementById('turn-banner');
    if (banner) {
      banner.style.background = 'rgba(212,144,58,0.2)';
      setTimeout(() => banner.style.background = '', 1000);
    }
  } else if (row.status === 'finished') {
    mpHandleGameFinished(row, localSeat);
  }
}

function mpHandleGameFinished(row, localSeat) {
  if (gameState) {
    gameState.winner = row.winner_seat;
    gameState.phase = 'ended';
  }
  showVictory(row.winner_seat);
}

function mpEndTurnLocal() {
  if (gameState.phase === 'ended') return;
  if (gameState.phase === 'draw') { showStatus('Draw your hand first', 'error'); return; }

  const pi = gameState.activePlayer;
  const p = gameState.players[pi];

  const newCharge = Math.min(p.ultimateCharge + 1, p.champion.ultimateCost);
  const ready = newCharge >= p.champion.ultimateCost && !p.ultimateUsed;

  const hadSkip = p.statusEffects.some(e => e.type === 'skip_move' && e.turnsRemaining === 1);
  let effects = p.statusEffects
    .map(e => ({ ...e, turnsRemaining: e.turnsRemaining - 1 }))
    .filter(e => e.turnsRemaining > 0);
  if (hadSkip && !effects.some(e => e.type === 'bind_cooldown')) {
    effects = [...effects, { type: 'bind_cooldown', turnsRemaining: 1 }];
  }

  gameState.players[pi] = { ...p, ultimateCharge: newCharge, ultimateReady: ready, statusEffects: effects };
  gameState.walls = gameState.walls.filter(w => !w.temporary || w.turnsRemaining > 1)
    .map(w => w.temporary ? { ...w, turnsRemaining: w.turnsRemaining - 1 } : w);

  onEndTurnPassives(pi);
  const next = pi === 0 ? 1 : 0;
  gameState.activePlayer = next;
  if (pi === 1) gameState.turnNumber++;
  gameState.phase = 'action'; // In MP, draw is handled locally

  uiMode = 'idle';
  selectedCard = null;
  resetTurnState();

  addLog(next, 'system', `Turn ${gameState.turnNumber} — Seat ${next}`);

  // Draw cards for the next player (this will be our opponent's hand — we store ours privately)
  // In MP, we only actually need to draw for the local player when it's their turn
  // Opponent's hand management is their own concern
  // Actually we don't draw here in MP — drawing is done when the turn starts on opponent's browser

  mpPushState();
}

// ── Push state to Supabase ───────────────────────────────────────────
async function mpPushState() {
  const sb = mpInit();
  if (!sb || !mp_gameId) return;

  showStatus('⟳ Syncing…', '');

  try {
    const nextSeat = gameState.activePlayer;
    const isFinished = gameState.winner !== null;

    // Before pushing, draw cards for the NEXT player (the one whose turn it will be)
    // We need to manage hand state for the next player
    await mpDrawForSeat(nextSeat);

    const sharedState = mpScrubHands(gameState);
    // Add deck length hints
    sharedState._hostDeckLen = gameState.players[0].deck.length;
    sharedState._guestDeckLen = gameState.players[1].deck.length;

    const update = {
      state:       sharedState,
      active_seat: nextSeat,
      status:      isFinished ? 'finished' : 'active',
      winner_seat: gameState.winner,
    };

    // Also update OUR hand in the DB (it may have changed from card plays)
    const myHandKey = mp_localSeat === 0 ? 'host_hand' : 'guest_hand';
    update[myHandKey] = JSON.stringify(gameState.players[mp_localSeat].hand);

    const { error } = await sb.from('mp_games').update(update).eq('id', mp_gameId);
    if (error) throw error;

    renderAll();
    mpUpdateTurnState();
    showStatus(`⏱ Waiting for ${mp_opponentName || 'opponent'}…`, '');
  } catch(e) {
    console.error('[MP] pushState error:', e);
    showStatus('Sync error — try ending turn again', 'error');
  }
}

// ── Draw cards for a given seat ──────────────────────────────────────
async function mpDrawForSeat(seat) {
  // We only actually draw if it's for our local seat (we own our hand)
  // For the opponent, we update their hand column in the DB from the current deck
  const sb = mpInit();
  if (!sb) return;

  const p = gameState.players[seat];
  if (!p) return;

  const isFirst = gameState.firstDraw?.[seat] ?? false;
  const drawCount = isFirst ? p.champion.cardDraw : 1;

  if (p.hand.length < p.champion.handSize) {
    const canDraw = Math.min(drawCount, p.champion.handSize - p.hand.length, p.deck.length);
    if (canDraw > 0) {
      // Rebuild deck if needed from champion
      if (p.deck.length === 0) {
        gameState.players[seat].deck = buildStarterDeck(p.champion.faction);
        // shuffle — already shuffled by buildStarterDeck
      }
      const drawn = gameState.players[seat].deck.splice(0, canDraw);
      gameState.players[seat].hand = [...gameState.players[seat].hand, ...drawn];
      if (isFirst && gameState.firstDraw) gameState.firstDraw[seat] = false;

      // Persist to opponent's hand column
      if (seat !== mp_localSeat) {
        const oppHandKey = seat === 0 ? 'host_hand' : 'guest_hand';
        await sb.from('mp_games').update({
          [oppHandKey]: JSON.stringify(gameState.players[seat].hand)
        }).eq('id', mp_gameId);
      }
    }
  }
}


function mpShowVictory(winner) {
  const overlay = document.getElementById('victory-overlay');
  if (!overlay) return;
  overlay.style.display = 'flex';
  const title = document.getElementById('victory-title');
  const subtitle = document.getElementById('victory-subtitle');
  const iWon = winner === mp_localSeat;
  const champName = gameState?.players[winner]?.champion?.name || '';
  if (title) { title.textContent = iWon ? 'YOU WIN!' : (mp_opponentName || 'OPPONENT') + ' WINS'; title.style.color = iWon ? 'var(--p0)' : 'var(--p1)'; }
  if (subtitle) subtitle.textContent = champName + ' reached the goal line — Turn ' + (gameState?.turnNumber || '?');
  const vt = document.getElementById('v-turns'); if (vt) vt.textContent = gameState?.turnNumber || '?';
  const vw = document.getElementById('v-walls'); if (vw) vw.textContent = (gameState?.walls?.filter(w => !w.isPhantom).length || 0);
}

// Guard functions called from onclick
function mpGuardedEndTurnHuman() {
  if (!mp_isMultiplayer) { endTurnHuman(); return; }
  if (gameState.activePlayer !== mp_localSeat) { showStatus("It's not your turn!", 'error'); return; }
  if (selectedCard && selectedCard._pendingMove && selectedCard.idx >= 0) {
    discardCard(gameState.activePlayer, selectedCard.idx);
    countCardPlayed(gameState.activePlayer);
    selectedCard = null; uiMode = 'idle';
  }
  mpEndTurnLocal();
}

function mpGuardedEnterMoveMode() {
  if (mp_isMultiplayer && gameState.activePlayer !== mp_localSeat) { showStatus("It's not your turn!", 'error'); return; }
  enterMoveMode();
}

// Patch core functions once DOM is ready
document.addEventListener('DOMContentLoaded', function mpPatch() {
  // renderAll — inject MP post-processing
  const _origRA = renderAll;
  window.renderAll = function() {
    _origRA();
    if (!mp_isMultiplayer) return;
    // Hide opponent hand
    const oppSeat = 1 - mp_localSeat;
    const oppHandEl = document.getElementById('p' + oppSeat + '-hand');
    if (oppHandEl) {
      const count = gameState._oppHandCount || 0;
      oppHandEl.innerHTML = count > 0
        ? Array(count).fill('<div class="hidden-card"><div class="hidden-card-icon"></div><span class="hidden-card-label">HIDDEN</span></div>').join('')
        : '<div style="font-size:10px;color:var(--text-dim);letter-spacing:.1em;padding:8px;border:1px solid var(--border);text-align:center;text-transform:uppercase;">Opponent Hand Hidden</div>';
    }
    // Turn banner override
    const banner = document.getElementById('turn-banner');
    const isMyTurn = gameState.activePlayer === mp_localSeat;
    const me = (gameState.players[mp_localSeat] && gameState.players[mp_localSeat].champion && gameState.players[mp_localSeat].champion.name) || '';
    const them = (gameState.players[1-mp_localSeat] && gameState.players[1-mp_localSeat].champion && gameState.players[1-mp_localSeat].champion.name) || '';
    const phase = gameState.phase;
    const phaseLabel = ({draw:'DRAW', action: isMyTurn ? 'YOUR TURN' : 'THEIR TURN', end_turn:'END', ended:'GAME OVER'})[phase] || phase;
    if (banner) {
      banner.textContent = isMyTurn
        ? 'YOU (' + me.toUpperCase() + ') — ' + phaseLabel
        : (mp_opponentName||'OPPONENT').toUpperCase() + ' (' + them.toUpperCase() + ') — ' + phaseLabel;
      banner.className = 'turn-banner p' + (isMyTurn ? mp_localSeat : 1-mp_localSeat);
    }
    // Disable buttons when not our turn
    const isMyPhase = isMyTurn && phase === 'action';
    const endBtn = document.getElementById('btn-end');
    const moveBtn = document.getElementById('btn-move');
    if (endBtn) { endBtn.disabled = !isMyPhase; endBtn.style.opacity = isMyPhase ? '1' : '0.3'; }
    if (moveBtn) { moveBtn.disabled = !isMyPhase; moveBtn.style.opacity = isMyPhase ? '1' : '0.3'; }
    if (!isMyTurn) {
      const myHandEl = document.getElementById('p' + mp_localSeat + '-hand');
      if (myHandEl) myHandEl.querySelectorAll('.card').forEach(function(el) {
        el.classList.add('card-disabled'); el.style.pointerEvents = 'none';
      });
    }
    mpUpdatePanelLabels();
  };

  // Patch buttons
  const endBtn = document.getElementById('btn-end');
  if (endBtn) endBtn.onclick = function() { mp_isMultiplayer ? mpGuardedEndTurnHuman() : endTurnHuman(); };
  const moveBtn = document.getElementById('btn-move');
  if (moveBtn) moveBtn.onclick = function() { mp_isMultiplayer ? mpGuardedEnterMoveMode() : enterMoveMode(); };

  // Patch handleCellClick
  const _origHCC = handleCellClick;
  window.handleCellClick = function(r, c) {
    if (mp_isMultiplayer && gameState.activePlayer !== mp_localSeat) { showStatus("It's not your turn!", 'error'); return; }
    _origHCC(r, c);
    if (mp_isMultiplayer && gameState.winner !== null) mpPushState();
  };

  // Patch handleWallClick
  const _origHWC = handleWallClick;
  window.handleWallClick = function(anchor, orientation, length, isPhantom, isDurable) {
    if (mp_isMultiplayer && gameState.activePlayer !== mp_localSeat) { showStatus("It's not your turn!", 'error'); return; }
    _origHWC(anchor, orientation, length, isPhantom, isDurable);
    if (mp_isMultiplayer && gameState.winner !== null) mpPushState();
  };

  // Patch performDraw
  const _origPD = performDraw;
  window.performDraw = function() {
    if (!mp_isMultiplayer) { _origPD(); return; }
    if (gameState.phase === 'draw') {
      gameState.phase = 'action';
      renderAll();
      updateActionBar();
      mpUpdateTurnState();
    }
  };

  // Patch showVictory
  const _origSV = showVictory;
  window.showVictory = function(winner) {
    if (!mp_isMultiplayer) { _origSV(winner); return; }
    mpShowVictory(winner);
    if (gameState.winner !== null && mp_gameId && _sb) {
      _sb.from('mp_games').update({ status: 'finished', winner_seat: gameState.winner, state: mpScrubHands(gameState) }).eq('id', mp_gameId).then(function(){});
    }
  };

  // Patch resetGame
  const _origRG = resetGame;
  window.resetGame = function() {
    if (mp_isMultiplayer) {
      mp_isMultiplayer = false; mp_gameId = null; mp_localSeat = null;
      if (mp_subscription && _sb) { _sb.removeChannel(mp_subscription); mp_subscription = null; }
      const p0Label = document.querySelector('#panel-p0 .panel-label');
      const p1Label = document.querySelector('#panel-p1 .panel-label');
      if (p0Label) p0Label.textContent = 'PLAYER 0';
      if (p1Label) p1Label.textContent = 'PLAYER 1';
    }
    _origRG();
  };
}, {once: true});

console.log('[CORRIDORS] Async Multiplayer module loaded. Configure SUPABASE_URL and SUPABASE_ANON to activate.');

</script>
</body>
</html>
